C0 C0 FF EE       # magic number
00 17             # version 11, arch = 1 (64 bits)

00 10             # int pool count
# int pool
7F FF FF FF
80 00 00 00
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 27 10
FF FF EF D2
00 00 10 2E
00 00 10 2E
00 00 5E 4E
FF FF A1 B2
FF FF EF D2
FF 00 00 00
FF 00 00 00
FF 00 00 00

03 5C             # string pool total size
# string pool
00  # ""
00  # ""
70 72 69 6E 74 5F 69 6D 61 67 65 20 69 73 20 6E 6F 74 20 61 20 75 73 65 66 75 6C 20 64 65 62 75 67 67 69 6E 67 20 74 6F 6F 6C 20 66 6F 72 20 6C 61 72 67 65 20 69 6D 61 67 65 73 0A 00  # "print_image is not a useful debugging tool for large images\n"
74 79 70 65 20 27 79 27 20 74 6F 20 70 72 6F 63 65 65 64 20 6E 6F 6E 65 74 68 65 6C 65 73 73 2C 20 00  # "type \'y\' to proceed nonetheless, "
61 6E 64 20 61 6E 79 74 68 69 6E 67 20 65 6C 73 65 20 74 6F 20 73 6B 69 70 20 70 72 69 6E 74 69 6E 67 3A 20 00  # "and anything else to skip printing: "
79 00  # "y"
59 00  # "Y"
20 00  # " "
0A 00  # "\n"
6D 61 73 6B 2E 63 30 3A 20 32 31 2E 35 2D 32 31 2E 37 34 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 21.5-21.74: assert failed"
6D 61 73 6B 2E 63 30 3A 20 32 34 2E 35 2D 32 34 2E 36 37 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 24.5-24.67: assert failed"
6D 61 73 6B 2E 63 30 3A 20 35 39 2E 31 33 2D 35 39 2E 35 39 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 59.13-59.59: assert failed"
6D 61 73 6B 2E 63 30 3A 20 36 30 2E 31 33 2D 36 30 2E 35 39 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 60.13-60.59: assert failed"
69 3D 00  # "i="
2C 20 6C 69 6D 69 74 3D 00  # ", limit="
2C 20 63 61 6C 6C 69 6E 67 20 63 61 6C 63 75 6C 61 74 65 0A 00  # ", calling calculate\n"
49 6E 70 75 74 20 69 6D 61 67 65 3A 20 20 00  # "Input image:  "
0A 00  # "\n"
4F 75 74 70 75 74 20 69 6D 61 67 65 3A 20 00  # "Output image: "
0A 0A 00  # "\n\n"
43 6F 75 6C 64 20 6E 6F 74 20 6C 6F 61 64 20 73 6F 75 72 63 65 20 69 6D 61 67 65 00  # "Could not load source image"
4C 6F 61 64 65 64 20 69 6D 61 67 65 2E 20 20 44 69 6D 65 6E 73 69 6F 6E 73 20 61 72 65 20 00  # "Loaded image.  Dimensions are "
20 62 79 20 00  # " by "
2E 0A 00  # ".\n"
55 6E 61 62 6C 65 20 74 6F 20 72 65 61 64 20 6D 61 73 6B 20 66 69 6C 65 2E 20 54 72 79 20 61 67 61 69 6E 2E 00  # "Unable to read mask file. Try again."
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
4C 69 6E 65 20 00  # "Line "
00  # ""
20 68 61 73 20 69 6E 76 61 6C 69 64 20 77 65 69 67 68 74 00  # " has invalid weight"
4E 6F 74 20 65 6E 6F 75 67 68 20 77 65 69 67 68 74 73 20 69 6E 20 6D 61 73 6B 20 66 69 6C 65 00  # "Not enough weights in mask file"
52 75 6E 6E 69 6E 67 20 62 6C 75 72 2E 2E 2E 00  # "Running blur..."
64 6F 6E 65 2E 0A 00  # "done.\n"
52 75 6E 6E 69 6E 67 20 53 6F 62 65 6C 20 4F 70 65 72 61 74 6F 72 20 58 2E 2E 2E 00  # "Running Sobel Operator X..."
64 6F 6E 65 2E 0A 00  # "done.\n"
52 75 6E 6E 69 6E 67 20 53 6F 62 65 6C 20 4F 70 65 72 61 74 6F 72 20 59 2E 2E 2E 00  # "Running Sobel Operator Y..."
64 6F 6E 65 2E 0A 00  # "done.\n"
53 61 76 69 6E 67 20 6F 75 74 70 75 74 2E 2E 2E 00  # "Saving output..."
64 6F 6E 65 2E 0A 00  # "done.\n"
2E 70 6E 67 00  # ".png"
49 6E 70 75 74 20 66 69 6C 65 20 64 6F 65 73 20 6E 6F 74 20 65 6E 64 20 77 69 74 68 20 2E 70 6E 67 00  # "Input file does not end with .png"
5F 00  # "_"
2E 70 6E 67 00  # ".png"
6D 61 73 6B 73 2F 6D 61 73 6B 2D 62 6C 75 72 2D 6D 6F 72 65 2E 74 78 74 00  # "masks/mask-blur-more.txt"
6D 61 73 6B 73 2F 6D 61 73 6B 2D 73 6F 62 65 6C 58 2E 74 78 74 00  # "masks/mask-sobelX.txt"
6D 61 73 6B 73 2F 6D 61 73 6B 2D 73 6F 62 65 6C 59 2E 74 78 74 00  # "masks/mask-sobelY.txt"
2D 6F 00  # "-o"
2D 69 00  # "-i"
00  # ""
55 73 61 67 65 3A 20 6D 61 73 6B 32 20 2D 69 20 3C 69 6E 70 75 74 20 69 6D 61 67 65 3E 20 5B 2D 6F 20 3C 6F 75 74 70 75 74 20 69 6D 61 67 65 3E 5D 00  # "Usage: mask2 -i <input image> [-o <output image>]"
00  # ""
6D 61 73 6B 65 64 67 65 00  # "maskedge"

00 1B             # function count
# function_pool

#<main>
00                # number of arguments = 0
04                # number of local variables = 4
00 8C             # code length = 140 bytes
BB 08    # new 8              # alloc(string)
36 00    # vstore 0           # output = alloc(string);
BB 08    # new 8              # alloc(string)
36 01    # vstore 1           # input = alloc(string);
10 03    # bipush 3           # 3
36 02    # vstore 2           # nmasks = 3;
15 02    # vload 2            # nmasks
BC 08    # newarray 8         # alloc_array(string, nmasks)
36 03    # vstore 3           # masks = alloc_array(string, nmasks);
15 03    # vload 3            # masks
10 00    # bipush 0           # 0
63       # aadds              # &masks[0]
14 02 D4 # aldc 724           # s[724] = "masks/mask-blur-more.txt"
4F       # amstore            # masks[0] = "masks/mask-blur-more.txt";
15 03    # vload 3            # masks
10 01    # bipush 1           # 1
63       # aadds              # &masks[1]
14 02 ED # aldc 749           # s[749] = "masks/mask-sobelX.txt"
4F       # amstore            # masks[1] = "masks/mask-sobelX.txt";
15 03    # vload 3            # masks
10 02    # bipush 2           # 2
63       # aadds              # &masks[2]
14 03 03 # aldc 771           # s[771] = "masks/mask-sobelY.txt"
4F       # amstore            # masks[2] = "masks/mask-sobelY.txt";
14 03 19 # aldc 793           # s[793] = "-o"
15 00    # vload 0            # output
B7 00 15 # invokenative 21    # args_string("-o", output)
57       # pop                # (ignore result)
14 03 1C # aldc 796           # s[796] = "-i"
15 01    # vload 1            # input
B7 00 15 # invokenative 21    # args_string("-i", input)
57       # pop                # (ignore result)
B7 00 16 # invokenative 22    # args_parse()
57       # pop                # (ignore result)
14 03 1F # aldc 799           # s[799] = ""
15 01    # vload 1            # input
2F       # amload             # *(input)
B7 00 05 # invokenative 5     # string_equal("", *(input))
10 01    # bipush 1           # true
9F 00 06 # if_cmpeq +6        # if (string_equal("", *(input)) == true) goto <178:then>
A7 00 0A # goto +10           # goto <179:else>
# <178:then>
14 03 20 # aldc 800           # s[800] = "Usage: mask2 -i <input image> [-o <output image>]"
BF       # athrow             # error "Usage: mask2 -i <input image> [-o <output image>]"
A7 00 03 # goto +3            # goto <180:endif>
# <179:else>
# <180:endif>
14 03 52 # aldc 850           # s[850] = ""
15 00    # vload 0            # output
2F       # amload             # *(output)
B7 00 05 # invokenative 5     # string_equal("", *(output))
10 01    # bipush 1           # true
9F 00 06 # if_cmpeq +6        # if (string_equal("", *(output)) == true) goto <181:then>
A7 00 12 # goto +18           # goto <182:else>
# <181:then>
15 00    # vload 0            # output
15 01    # vload 1            # input
2F       # amload             # *(input)
14 03 53 # aldc 851           # s[851] = "maskedge"
B8 00 1A # invokestatic 26    # default_output(*(input), "maskedge")
4F       # amstore            # *(output) = default_output(*(input), "maskedge");
A7 00 03 # goto +3            # goto <183:endif>
# <182:else>
# <183:endif>
15 01    # vload 1            # input
2F       # amload             # *(input)
15 00    # vload 0            # output
2F       # amload             # *(output)
15 03    # vload 3            # masks
15 02    # vload 2            # nmasks
B8 00 19 # invokestatic 25    # mask_main(*(input), *(output), masks, nmasks)
57       # pop                # (ignore result)
10 00    # bipush 0           # 0
B0       # return             # 


#<int_size>
00                # number of arguments = 0
00                # number of local variables = 0
00 03             # code length = 3 bytes
10 04    # bipush 4           # 4
B0       # return             # 


#<int_max>
00                # number of arguments = 0
00                # number of local variables = 0
00 04             # code length = 4 bytes
13 00 00 # ildc 0             # c[0] = 2147483647
B0       # return             # 


#<int_min>
00                # number of arguments = 0
00                # number of local variables = 0
00 04             # code length = 4 bytes
13 00 01 # ildc 1             # c[1] = -2147483648
B0       # return             # 


#<abs>
01                # number of arguments = 1
01                # number of local variables = 1
00 15             # code length = 21 bytes
15 00    # vload 0            # x
10 00    # bipush 0           # 0
A1 00 06 # if_icmplt +6       # if (x < 0) goto <06:cond_true>
A7 00 0B # goto +11           # goto <07:cond_false>
# <06:cond_true>
10 00    # bipush 0           # 
15 00    # vload 0            # x
64       # isub               # -(x)
A7 00 05 # goto +5            # goto <08:cond_end>
# <07:cond_false>
15 00    # vload 0            # x
# <08:cond_end>
B0       # return             # 


#<max>
02                # number of arguments = 2
02                # number of local variables = 2
00 12             # code length = 18 bytes
15 00    # vload 0            # x
15 01    # vload 1            # y
A3 00 06 # if_icmpgt +6       # if (x > y) goto <00:cond_true>
A7 00 08 # goto +8            # goto <01:cond_false>
# <00:cond_true>
15 00    # vload 0            # x
A7 00 05 # goto +5            # goto <02:cond_end>
# <01:cond_false>
15 01    # vload 1            # y
# <02:cond_end>
B0       # return             # 


#<min>
02                # number of arguments = 2
02                # number of local variables = 2
00 12             # code length = 18 bytes
15 00    # vload 0            # x
15 01    # vload 1            # y
A3 00 06 # if_icmpgt +6       # if (x > y) goto <03:cond_true>
A7 00 08 # goto +8            # goto <04:cond_false>
# <03:cond_true>
15 01    # vload 1            # y
A7 00 05 # goto +5            # goto <05:cond_end>
# <04:cond_false>
15 00    # vload 0            # x
# <05:cond_end>
B0       # return             # 


#<int2hex>
01                # number of arguments = 1
04                # number of local variables = 4
00 52             # code length = 82 bytes
10 02    # bipush 2           # 2
B8 00 01 # invokestatic 1     # int_size()
68       # imul               # (2 * int_size())
36 01    # vstore 1           # digits = (2 * int_size());
15 01    # vload 1            # digits
10 01    # bipush 1           # 1
60       # iadd               # (digits + 1)
BC 01    # newarray 1         # alloc_array(char, (digits + 1))
36 02    # vstore 2           # s = alloc_array(char, (digits + 1));
15 02    # vload 2            # s
15 01    # vload 1            # digits
63       # aadds              # &s[digits]
10 00    # bipush 0           # '\000'
55       # cmstore            # s[digits] = '\0';
10 00    # bipush 0           # 0
36 03    # vstore 3           # i = 0;
# <17:loop>
15 03    # vload 3            # i
15 01    # vload 1            # digits
A1 00 06 # if_icmplt +6       # if (i < digits) goto <18:body>
A7 00 28 # goto +40           # goto <19:exit>
# <18:body>
15 02    # vload 2            # s
15 01    # vload 1            # digits
15 03    # vload 3            # i
64       # isub               # (digits - i)
10 01    # bipush 1           # 1
64       # isub               # ((digits - i) - 1)
63       # aadds              # &s[((digits - i) - 1)]
15 00    # vload 0            # x
10 0F    # bipush 15          # 15
7E       # iand               # (x & 15)
B8 00 08 # invokestatic 8     # hexdig2char((x & 15))
55       # cmstore            # s[((digits - i) - 1)] = hexdig2char((x & 15));
15 00    # vload 0            # x
10 04    # bipush 4           # 4
7A       # ishr               # (x >> 4)
36 00    # vstore 0           # x = (x >> 4);
15 03    # vload 3            # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 03    # vstore 3           # i += 1;
A7 FF D4 # goto -44           # goto <17:loop>
# <19:exit>
15 02    # vload 2            # s
B7 00 02 # invokenative 2     # string_from_chararray(s)
B0       # return             # 


#<hexdig2char>
01                # number of arguments = 1
01                # number of local variables = 1
00 4C             # code length = 76 bytes
10 00    # bipush 0           # 0
15 00    # vload 0            # d
A4 00 06 # if_icmple +6       # if (0 <= d) goto <12:and>
A7 00 1C # goto +28           # goto <10:else>
# <12:and>
15 00    # vload 0            # d
10 0A    # bipush 10          # 10
A1 00 06 # if_icmplt +6       # if (d < 10) goto <09:then>
A7 00 12 # goto +18           # goto <10:else>
# <09:then>
10 30    # bipush 48          # '0'
B7 00 01 # invokenative 1     # char_ord('0')
15 00    # vload 0            # d
60       # iadd               # (char_ord('0') + d)
B7 00 00 # invokenative 0     # char_chr((char_ord('0') + d))
B0       # return             # 
A7 00 2C # goto +44           # goto <11:endif>
# <10:else>
10 0A    # bipush 10          # 10
15 00    # vload 0            # d
A4 00 06 # if_icmple +6       # if (10 <= d) goto <16:and>
A7 00 1F # goto +31           # goto <14:else>
# <16:and>
15 00    # vload 0            # d
10 10    # bipush 16          # 16
A1 00 06 # if_icmplt +6       # if (d < 16) goto <13:then>
A7 00 15 # goto +21           # goto <14:else>
# <13:then>
10 41    # bipush 65          # 'A'
B7 00 01 # invokenative 1     # char_ord('A')
15 00    # vload 0            # d
10 0A    # bipush 10          # 10
64       # isub               # (d - 10)
60       # iadd               # (char_ord('A') + (d - 10))
B7 00 00 # invokenative 0     # char_chr((char_ord('A') + (d - 10)))
B0       # return             # 
A7 00 06 # goto +6            # goto <15:endif>
# <14:else>
10 3F    # bipush 63          # '\?'
B0       # return             # 
# <15:endif>
# <11:endif>


#<get_red>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 02 # ildc 2             # c[2] = 255
15 00    # vload 0            # p
10 10    # bipush 16          # 16
7A       # ishr               # (p >> 16)
7E       # iand               # (255 & (p >> 16))
B0       # return             # 


#<get_green>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 03 # ildc 3             # c[3] = 255
15 00    # vload 0            # p
10 08    # bipush 8           # 8
7A       # ishr               # (p >> 8)
7E       # iand               # (255 & (p >> 8))
B0       # return             # 


#<get_blue>
01                # number of arguments = 1
01                # number of local variables = 1
00 07             # code length = 7 bytes
13 00 04 # ildc 4             # c[4] = 255
15 00    # vload 0            # p
7E       # iand               # (255 & p)
B0       # return             # 


#<get_alpha>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 05 # ildc 5             # c[5] = 255
15 00    # vload 0            # p
10 18    # bipush 24          # 24
7A       # ishr               # (p >> 24)
7E       # iand               # (255 & (p >> 24))
B0       # return             # 


#<make_pixel>
04                # number of arguments = 4
04                # number of local variables = 4
00 15             # code length = 21 bytes
15 00    # vload 0            # alpha
10 18    # bipush 24          # 24
78       # ishl               # (alpha << 24)
15 01    # vload 1            # red
10 10    # bipush 16          # 16
78       # ishl               # (red << 16)
80       # ior                # ((alpha << 24) | (red << 16))
15 02    # vload 2            # green
10 08    # bipush 8           # 8
78       # ishl               # (green << 8)
80       # ior                # (((alpha << 24) | (red << 16)) | (green << 8))
15 03    # vload 3            # blue
80       # ior                # ((((alpha << 24) | (red << 16)) | (green << 8)) | blue)
B0       # return             # 


#<pixel_print>
01                # number of arguments = 1
01                # number of local variables = 1
00 1A             # code length = 26 bytes
14 00 00 # aldc 0             # s[0] = ""
B7 00 03 # invokenative 3     # print("")
57       # pop                # (ignore result)
15 00    # vload 0            # p
B8 00 07 # invokestatic 7     # int2hex(p)
B7 00 03 # invokenative 3     # print(int2hex(p))
57       # pop                # (ignore result)
14 00 01 # aldc 1             # s[1] = ""
B7 00 03 # invokenative 3     # print("")
57       # pop                # (ignore result)
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<is_valid_imagesize>
02                # number of arguments = 2
02                # number of local variables = 2
00 2F             # code length = 47 bytes
15 00    # vload 0            # width
10 00    # bipush 0           # 0
A3 00 06 # if_icmpgt +6       # if (width > 0) goto <23:and>
A7 00 25 # goto +37           # goto <21:cond_false>
# <23:and>
15 01    # vload 1            # height
10 00    # bipush 0           # 0
A3 00 06 # if_icmpgt +6       # if (height > 0) goto <20:cond_true>
A7 00 1B # goto +27           # goto <21:cond_false>
# <20:cond_true>
15 00    # vload 0            # width
B8 00 02 # invokestatic 2     # int_max()
15 01    # vload 1            # height
6C       # idiv               # (int_max() / height)
A4 00 06 # if_icmple +6       # if (width <= (int_max() / height)) goto <24:cond_true>
A7 00 08 # goto +8            # goto <25:cond_false>
# <24:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <26:cond_end>
# <25:cond_false>
10 00    # bipush 0           # false
# <26:cond_end>
A7 00 05 # goto +5            # goto <22:cond_end>
# <21:cond_false>
10 00    # bipush 0           # false
# <22:cond_end>
B0       # return             # 


#<get_row>
03                # number of arguments = 3
03                # number of local variables = 3
00 06             # code length = 6 bytes
15 00    # vload 0            # index
15 01    # vload 1            # width
6C       # idiv               # (index / width)
B0       # return             # 


#<get_column>
03                # number of arguments = 3
04                # number of local variables = 4
00 14             # code length = 20 bytes
15 00    # vload 0            # index
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 10 # invokestatic 16    # get_row(index, width, height)
36 03    # vstore 3           # row = get_row(index, width, height);
15 00    # vload 0            # index
15 03    # vload 3            # row
15 01    # vload 1            # width
68       # imul               # (row * width)
64       # isub               # (index - (row * width))
B0       # return             # 


#<is_valid_pixel>
04                # number of arguments = 4
04                # number of local variables = 4
00 69             # code length = 105 bytes
10 00    # bipush 0           # 0
15 00    # vload 0            # row
A4 00 06 # if_icmple +6       # if (0 <= row) goto <34:and>
A7 00 5F # goto +95           # goto <28:cond_false>
# <34:and>
15 00    # vload 0            # row
15 03    # vload 3            # height
A1 00 06 # if_icmplt +6       # if (row < height) goto <33:and>
A7 00 55 # goto +85           # goto <28:cond_false>
# <33:and>
10 00    # bipush 0           # 0
15 01    # vload 1            # col
A4 00 06 # if_icmple +6       # if (0 <= col) goto <32:and>
A7 00 4B # goto +75           # goto <28:cond_false>
# <32:and>
15 01    # vload 1            # col
15 02    # vload 2            # width
A1 00 06 # if_icmplt +6       # if (col < width) goto <31:and>
A7 00 41 # goto +65           # goto <28:cond_false>
# <31:and>
15 00    # vload 0            # row
B8 00 02 # invokestatic 2     # int_max()
15 01    # vload 1            # col
64       # isub               # (int_max() - col)
15 02    # vload 2            # width
6C       # idiv               # ((int_max() - col) / width)
A4 00 06 # if_icmple +6       # if (row <= ((int_max() - col) / width)) goto <30:and>
A7 00 30 # goto +48           # goto <28:cond_false>
# <30:and>
10 00    # bipush 0           # 0
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
A4 00 06 # if_icmple +6       # if (0 <= ((row * width) + col)) goto <27:cond_true>
A7 00 20 # goto +32           # goto <28:cond_false>
# <27:cond_true>
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
15 02    # vload 2            # width
15 03    # vload 3            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (((row * width) + col) < (width * height)) goto <35:cond_true>
A7 00 08 # goto +8            # goto <36:cond_false>
# <35:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <37:cond_end>
# <36:cond_false>
10 00    # bipush 0           # false
# <37:cond_end>
A7 00 05 # goto +5            # goto <29:cond_end>
# <28:cond_false>
10 00    # bipush 0           # false
# <29:cond_end>
B0       # return             # 


#<get_index>
04                # number of arguments = 4
04                # number of local variables = 4
00 09             # code length = 9 bytes
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
B0       # return             # 


#<image_print>
03                # number of arguments = 3
05                # number of local variables = 5
00 AB             # code length = 171 bytes
15 01    # vload 1            # width
10 0A    # bipush 10          # 10
A3 00 10 # if_icmpgt +16      # if (width > 10) goto <38:then>
A7 00 03 # goto +3            # goto <41:or>
# <41:or>
15 02    # vload 2            # height
10 0A    # bipush 10          # 10
A3 00 06 # if_icmpgt +6       # if (height > 10) goto <38:then>
A7 00 46 # goto +70           # goto <39:else>
# <38:then>
14 00 02 # aldc 2             # s[2] = "print_image is not a useful debugging tool for large images\n"
B7 00 03 # invokenative 3     # print("print_image is not a useful debugging tool for large images\n")
57       # pop                # (ignore result)
14 00 3F # aldc 63            # s[63] = "type \'y\' to proceed nonetheless, "
B7 00 03 # invokenative 3     # print("type \'y\' to proceed nonetheless, ")
57       # pop                # (ignore result)
14 00 61 # aldc 97            # s[97] = "and anything else to skip printing: "
B7 00 03 # invokenative 3     # print("and anything else to skip printing: ")
57       # pop                # (ignore result)
B7 00 04 # invokenative 4     # readline()
36 03    # vstore 3           # s = readline();
15 03    # vload 3            # s
14 00 86 # aldc 134           # s[134] = "y"
B7 00 05 # invokenative 5     # string_equal(s, "y")
10 01    # bipush 1           # true
9F 00 1C # if_cmpeq +28       # if (string_equal(s, "y") == true) goto <43:else>
A7 00 03 # goto +3            # goto <45:or>
# <45:or>
15 03    # vload 3            # s
14 00 88 # aldc 136           # s[136] = "Y"
B7 00 05 # invokenative 5     # string_equal(s, "Y")
10 01    # bipush 1           # true
9F 00 0C # if_cmpeq +12       # if (string_equal(s, "Y") == true) goto <43:else>
A7 00 03 # goto +3            # goto <42:then>
# <42:then>
10 00    # bipush 0           # dummy return value
B0       # return             # 
A7 00 03 # goto +3            # goto <44:endif>
# <43:else>
# <44:endif>
A7 00 03 # goto +3            # goto <40:endif>
# <39:else>
# <40:endif>
10 00    # bipush 0           # 0
36 03    # vstore 3           # row = 0;
# <46:loop>
15 03    # vload 3            # row
15 02    # vload 2            # height
A1 00 06 # if_icmplt +6       # if (row < height) goto <47:body>
A7 00 46 # goto +70           # goto <48:exit>
# <47:body>
10 00    # bipush 0           # 0
36 04    # vstore 4           # col = 0;
# <49:loop>
15 04    # vload 4            # col
15 01    # vload 1            # width
A1 00 06 # if_icmplt +6       # if (col < width) goto <50:body>
A7 00 27 # goto +39           # goto <51:exit>
# <50:body>
15 00    # vload 0            # A
15 03    # vload 3            # row
15 04    # vload 4            # col
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 13 # invokestatic 19    # get_index(row, col, width, height)
63       # aadds              # &A[get_index(row, col, width, height)]
2E       # imload             # A[get_index(row, col, width, height)]
B8 00 0E # invokestatic 14    # pixel_print(A[get_index(row, col, width, height)])
57       # pop                # (ignore result)
14 00 8A # aldc 138           # s[138] = " "
B7 00 03 # invokenative 3     # print(" ")
57       # pop                # (ignore result)
15 04    # vload 4            # col
10 01    # bipush 1           # 1
60       # iadd               # 
36 04    # vstore 4           # col += 1;
A7 FF D5 # goto -43           # goto <49:loop>
# <51:exit>
14 00 8C # aldc 140           # s[140] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
15 03    # vload 3            # row
10 01    # bipush 1           # 1
60       # iadd               # 
36 03    # vstore 3           # row += 1;
A7 FF B6 # goto -74           # goto <46:loop>
# <48:exit>
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<calculate_mask>
06                # number of arguments = 6
19                # number of local variables = 25
01 C0             # code length = 448 bytes
15 04    # vload 4            # maskwidth
10 02    # bipush 2           # 2
6C       # idiv               # (maskwidth / 2)
36 06    # vstore 6           # maskwidth_half = (maskwidth / 2);
15 05    # vload 5            # i
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 10 # invokestatic 16    # get_row(i, width, height)
36 07    # vstore 7           # center_row = get_row(i, width, height);
15 05    # vload 5            # i
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 11 # invokestatic 17    # get_column(i, width, height)
36 08    # vstore 8           # center_col = get_column(i, width, height);
15 07    # vload 7            # center_row
15 06    # vload 6            # maskwidth_half
64       # isub               # (center_row - maskwidth_half)
10 00    # bipush 0           # 0
B8 00 05 # invokestatic 5     # max((center_row - maskwidth_half), 0)
36 09    # vstore 9           # left_row = max((center_row - maskwidth_half), 0);
15 07    # vload 7            # center_row
15 06    # vload 6            # maskwidth_half
60       # iadd               # (center_row + maskwidth_half)
15 02    # vload 2            # height
10 01    # bipush 1           # 1
64       # isub               # (height - 1)
B8 00 06 # invokestatic 6     # min((center_row + maskwidth_half), (height - 1))
36 0A    # vstore 10          # right_row = min((center_row + maskwidth_half), (height - 1));
10 00    # bipush 0           # 0
15 09    # vload 9            # left_row
A4 00 06 # if_icmple +6       # if (0 <= left_row) goto <55:and>
A7 00 21 # goto +33           # goto <53:cond_false>
# <55:and>
15 09    # vload 9            # left_row
15 0A    # vload 10           # right_row
A4 00 06 # if_icmple +6       # if (left_row <= right_row) goto <52:cond_true>
A7 00 17 # goto +23           # goto <53:cond_false>
# <52:cond_true>
15 0A    # vload 10           # right_row
15 02    # vload 2            # height
A1 00 06 # if_icmplt +6       # if (right_row < height) goto <56:cond_true>
A7 00 08 # goto +8            # goto <57:cond_false>
# <56:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <58:cond_end>
# <57:cond_false>
10 00    # bipush 0           # false
# <58:cond_end>
A7 00 05 # goto +5            # goto <54:cond_end>
# <53:cond_false>
10 00    # bipush 0           # false
# <54:cond_end>
14 00 8E # aldc 142           # s[142] = "mask.c0: 21.5-21.74: assert failed"
CF       # assert             # assert (((0 <= left_row) && (left_row <= right_row)) && (right_row < height)) [failure message on stack]
15 08    # vload 8            # center_col
15 06    # vload 6            # maskwidth_half
64       # isub               # (center_col - maskwidth_half)
10 00    # bipush 0           # 0
B8 00 05 # invokestatic 5     # max((center_col - maskwidth_half), 0)
36 0B    # vstore 11          # up_col = max((center_col - maskwidth_half), 0);
15 08    # vload 8            # center_col
15 06    # vload 6            # maskwidth_half
60       # iadd               # (center_col + maskwidth_half)
15 01    # vload 1            # width
10 01    # bipush 1           # 1
64       # isub               # (width - 1)
B8 00 06 # invokestatic 6     # min((center_col + maskwidth_half), (width - 1))
36 0C    # vstore 12          # down_col = min((center_col + maskwidth_half), (width - 1));
10 00    # bipush 0           # 0
15 0B    # vload 11           # up_col
A4 00 06 # if_icmple +6       # if (0 <= up_col) goto <62:and>
A7 00 21 # goto +33           # goto <60:cond_false>
# <62:and>
15 0B    # vload 11           # up_col
15 0C    # vload 12           # down_col
A4 00 06 # if_icmple +6       # if (up_col <= down_col) goto <59:cond_true>
A7 00 17 # goto +23           # goto <60:cond_false>
# <59:cond_true>
15 0C    # vload 12           # down_col
15 01    # vload 1            # width
A1 00 06 # if_icmplt +6       # if (down_col < width) goto <63:cond_true>
A7 00 08 # goto +8            # goto <64:cond_false>
# <63:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <65:cond_end>
# <64:cond_false>
10 00    # bipush 0           # false
# <65:cond_end>
A7 00 05 # goto +5            # goto <61:cond_end>
# <60:cond_false>
10 00    # bipush 0           # false
# <61:cond_end>
14 00 B1 # aldc 177           # s[177] = "mask.c0: 24.5-24.67: assert failed"
CF       # assert             # assert (((0 <= up_col) && (up_col <= down_col)) && (down_col < width)) [failure message on stack]
10 FF    # bipush -1          # -1
36 0D    # vstore 13          # this_index = -(1);
10 FF    # bipush -1          # -1
36 0E    # vstore 14          # red = -(1);
10 FF    # bipush -1          # -1
36 0F    # vstore 15          # green = -(1);
10 FF    # bipush -1          # -1
36 10    # vstore 16          # blue = -(1);
10 FF    # bipush -1          # -1
36 11    # vstore 17          # average = -(1);
10 FF    # bipush -1          # -1
36 12    # vstore 18          # mask_row = -(1);
10 FF    # bipush -1          # -1
36 13    # vstore 19          # mask_col = -(1);
10 FF    # bipush -1          # -1
36 14    # vstore 20          # mask_index = -(1);
10 FF    # bipush -1          # -1
36 15    # vstore 21          # weight = -(1);
10 00    # bipush 0           # 0
36 16    # vstore 22          # result = 0;
15 09    # vload 9            # left_row
36 17    # vstore 23          # row = left_row;
# <66:loop>
15 17    # vload 23           # row
15 0A    # vload 10           # right_row
A4 00 06 # if_icmple +6       # if (row <= right_row) goto <67:body>
A7 00 DB # goto +219          # goto <68:exit>
# <67:body>
15 0B    # vload 11           # up_col
36 18    # vstore 24          # col = up_col;
# <69:loop>
15 18    # vload 24           # col
15 0C    # vload 12           # down_col
A4 00 06 # if_icmple +6       # if (col <= down_col) goto <70:body>
A7 00 C3 # goto +195          # goto <71:exit>
# <70:body>
15 17    # vload 23           # row
15 18    # vload 24           # col
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 13 # invokestatic 19    # get_index(row, col, width, height)
36 0D    # vstore 13          # this_index = get_index(row, col, width, height);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 09 # invokestatic 9     # get_red(pixels[this_index])
36 0E    # vstore 14          # red = get_red(pixels[this_index]);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 0A # invokestatic 10    # get_green(pixels[this_index])
36 0F    # vstore 15          # green = get_green(pixels[this_index]);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 0B # invokestatic 11    # get_blue(pixels[this_index])
36 10    # vstore 16          # blue = get_blue(pixels[this_index]);
15 0E    # vload 14           # red
15 0F    # vload 15           # green
60       # iadd               # (red + green)
15 10    # vload 16           # blue
60       # iadd               # ((red + green) + blue)
10 03    # bipush 3           # 3
6C       # idiv               # (((red + green) + blue) / 3)
36 11    # vstore 17          # average = (((red + green) + blue) / 3);
15 06    # vload 6            # maskwidth_half
15 07    # vload 7            # center_row
15 17    # vload 23           # row
64       # isub               # (center_row - row)
64       # isub               # (maskwidth_half - (center_row - row))
36 12    # vstore 18          # mask_row = (maskwidth_half - (center_row - row));
15 06    # vload 6            # maskwidth_half
15 08    # vload 8            # center_col
15 18    # vload 24           # col
64       # isub               # (center_col - col)
64       # isub               # (maskwidth_half - (center_col - col))
36 13    # vstore 19          # mask_col = (maskwidth_half - (center_col - col));
10 00    # bipush 0           # 0
15 12    # vload 18           # mask_row
A4 00 06 # if_icmple +6       # if (0 <= mask_row) goto <72:cond_true>
A7 00 17 # goto +23           # goto <73:cond_false>
# <72:cond_true>
15 12    # vload 18           # mask_row
15 04    # vload 4            # maskwidth
A1 00 06 # if_icmplt +6       # if (mask_row < maskwidth) goto <75:cond_true>
A7 00 08 # goto +8            # goto <76:cond_false>
# <75:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <77:cond_end>
# <76:cond_false>
10 00    # bipush 0           # false
# <77:cond_end>
A7 00 05 # goto +5            # goto <74:cond_end>
# <73:cond_false>
10 00    # bipush 0           # false
# <74:cond_end>
14 00 D4 # aldc 212           # s[212] = "mask.c0: 59.13-59.59: assert failed"
CF       # assert             # assert ((0 <= mask_row) && (mask_row < maskwidth)) [failure message on stack]
10 00    # bipush 0           # 0
15 13    # vload 19           # mask_col
A4 00 06 # if_icmple +6       # if (0 <= mask_col) goto <78:cond_true>
A7 00 17 # goto +23           # goto <79:cond_false>
# <78:cond_true>
15 13    # vload 19           # mask_col
15 04    # vload 4            # maskwidth
A1 00 06 # if_icmplt +6       # if (mask_col < maskwidth) goto <81:cond_true>
A7 00 08 # goto +8            # goto <82:cond_false>
# <81:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <83:cond_end>
# <82:cond_false>
10 00    # bipush 0           # false
# <83:cond_end>
A7 00 05 # goto +5            # goto <80:cond_end>
# <79:cond_false>
10 00    # bipush 0           # false
# <80:cond_end>
14 00 F8 # aldc 248           # s[248] = "mask.c0: 60.13-60.59: assert failed"
CF       # assert             # assert ((0 <= mask_col) && (mask_col < maskwidth)) [failure message on stack]
15 12    # vload 18           # mask_row
15 13    # vload 19           # mask_col
15 04    # vload 4            # maskwidth
15 04    # vload 4            # maskwidth
B8 00 13 # invokestatic 19    # get_index(mask_row, mask_col, maskwidth, maskwidth)
36 14    # vstore 20          # mask_index = get_index(mask_row, mask_col, maskwidth, maskwidth);
15 03    # vload 3            # mask
15 14    # vload 20           # mask_index
63       # aadds              # &mask[mask_index]
2E       # imload             # mask[mask_index]
36 15    # vstore 21          # weight = mask[mask_index];
15 16    # vload 22           # result
15 11    # vload 17           # average
15 15    # vload 21           # weight
68       # imul               # (average * weight)
60       # iadd               # 
36 16    # vstore 22          # result += (average * weight);
15 18    # vload 24           # col
10 01    # bipush 1           # 1
60       # iadd               # 
36 18    # vstore 24          # col += 1;
A7 FF 39 # goto -199          # goto <69:loop>
# <71:exit>
15 17    # vload 23           # row
10 01    # bipush 1           # 1
60       # iadd               # 
36 17    # vstore 23          # row += 1;
A7 FF 21 # goto -223          # goto <66:loop>
# <68:exit>
15 16    # vload 22           # result
B0       # return             # 


#<apply_mask>
05                # number of arguments = 5
09                # number of local variables = 9
00 69             # code length = 105 bytes
15 01    # vload 1            # width
15 02    # vload 2            # height
68       # imul               # (width * height)
BC 04    # newarray 4         # alloc_array(int, (width * height))
36 05    # vstore 5           # masked_pixels = alloc_array(int, (width * height));
10 FF    # bipush -1          # -1
36 06    # vstore 6           # result = -(1);
15 01    # vload 1            # width
15 02    # vload 2            # height
68       # imul               # (width * height)
36 07    # vstore 7           # limit = (width * height);
10 00    # bipush 0           # 0
36 08    # vstore 8           # i = 0;
# <84:loop>
15 08    # vload 8            # i
15 07    # vload 7            # limit
A1 00 06 # if_icmplt +6       # if (i < limit) goto <85:body>
A7 00 47 # goto +71           # goto <86:exit>
# <85:body>
14 01 1C # aldc 284           # s[284] = "i="
B7 00 03 # invokenative 3     # print("i=")
57       # pop                # (ignore result)
15 08    # vload 8            # i
B7 00 06 # invokenative 6     # printint(i)
57       # pop                # (ignore result)
14 01 1F # aldc 287           # s[287] = ", limit="
B7 00 03 # invokenative 3     # print(", limit=")
57       # pop                # (ignore result)
15 07    # vload 7            # limit
B7 00 06 # invokenative 6     # printint(limit)
57       # pop                # (ignore result)
14 01 28 # aldc 296           # s[296] = ", calling calculate\n"
B7 00 03 # invokenative 3     # print(", calling calculate\n")
57       # pop                # (ignore result)
15 00    # vload 0            # pixels
15 01    # vload 1            # width
15 02    # vload 2            # height
15 03    # vload 3            # mask
15 04    # vload 4            # maskwidth
15 08    # vload 8            # i
B8 00 15 # invokestatic 21    # calculate_mask(pixels, width, height, mask, maskwidth, i)
36 06    # vstore 6           # result = calculate_mask(pixels, width, height, mask, maskwidth, i);
15 05    # vload 5            # masked_pixels
15 08    # vload 8            # i
63       # aadds              # &masked_pixels[i]
15 06    # vload 6            # result
4E       # imstore            # masked_pixels[i] = result;
15 08    # vload 8            # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 08    # vstore 8           # i += 1;
A7 FF B5 # goto -75           # goto <84:loop>
# <86:exit>
15 05    # vload 5            # masked_pixels
B0       # return             # 


#<isqrt>
01                # number of arguments = 1
03                # number of local variables = 3
00 39             # code length = 57 bytes
10 00    # bipush 0           # 0
36 01    # vstore 1           # i = 0;
10 00    # bipush 0           # 0
36 02    # vstore 2           # k = 0;
# <87:loop>
10 00    # bipush 0           # 0
15 02    # vload 2            # k
A4 00 06 # if_icmple +6       # if (0 <= k) goto <90:and>
A7 00 24 # goto +36           # goto <89:exit>
# <90:and>
15 02    # vload 2            # k
15 00    # vload 0            # n
A4 00 06 # if_icmple +6       # if (k <= n) goto <88:body>
A7 00 1A # goto +26           # goto <89:exit>
# <88:body>
15 02    # vload 2            # k
10 02    # bipush 2           # 2
15 01    # vload 1            # i
68       # imul               # (2 * i)
60       # iadd               # (k + (2 * i))
10 01    # bipush 1           # 1
60       # iadd               # ((k + (2 * i)) + 1)
36 02    # vstore 2           # k = ((k + (2 * i)) + 1);
15 01    # vload 1            # i
10 01    # bipush 1           # 1
60       # iadd               # (i + 1)
36 01    # vstore 1           # i = (i + 1);
A7 FF D8 # goto -40           # goto <87:loop>
# <89:exit>
15 01    # vload 1            # i
10 01    # bipush 1           # 1
64       # isub               # (i - 1)
B0       # return             # 


#<direction>
02                # number of arguments = 2
03                # number of local variables = 3
00 8C             # code length = 140 bytes
15 01    # vload 1            # x
10 00    # bipush 0           # 0
9F 00 06 # if_cmpeq +6        # if (x == 0) goto <94:and>
A7 00 13 # goto +19           # goto <92:else>
# <94:and>
15 00    # vload 0            # y
10 00    # bipush 0           # 0
9F 00 06 # if_cmpeq +6        # if (y == 0) goto <91:then>
A7 00 09 # goto +9            # goto <92:else>
# <91:then>
10 00    # bipush 0           # 0
B0       # return             # 
A7 00 03 # goto +3            # goto <93:endif>
# <92:else>
# <93:endif>
15 01    # vload 1            # x
10 00    # bipush 0           # 0
9F 00 06 # if_cmpeq +6        # if (x == 0) goto <95:then>
A7 00 09 # goto +9            # goto <96:else>
# <95:then>
10 5A    # bipush 90          # 90
B0       # return             # 
A7 00 03 # goto +3            # goto <97:endif>
# <96:else>
# <97:endif>
13 00 06 # ildc 6             # c[6] = 10000
15 00    # vload 0            # y
68       # imul               # (10000 * y)
15 01    # vload 1            # x
6C       # idiv               # ((10000 * y) / x)
36 02    # vstore 2           # q = ((10000 * y) / x);
15 02    # vload 2            # q
13 00 07 # ildc 7             # c[7] = -4142
A3 00 06 # if_icmpgt +6       # if (q > -(4142)) goto <101:and>
A7 00 14 # goto +20           # goto <99:else>
# <101:and>
15 02    # vload 2            # q
13 00 08 # ildc 8             # c[8] = 4142
A4 00 06 # if_icmple +6       # if (q <= 4142) goto <98:then>
A7 00 09 # goto +9            # goto <99:else>
# <98:then>
10 00    # bipush 0           # 0
B0       # return             # 
A7 00 3E # goto +62           # goto <100:endif>
# <99:else>
15 02    # vload 2            # q
13 00 09 # ildc 9             # c[9] = 4142
A3 00 06 # if_icmpgt +6       # if (q > 4142) goto <105:and>
A7 00 14 # goto +20           # goto <103:else>
# <105:and>
15 02    # vload 2            # q
13 00 0A # ildc 10            # c[10] = 24142
A4 00 06 # if_icmple +6       # if (q <= 24142) goto <102:then>
A7 00 09 # goto +9            # goto <103:else>
# <102:then>
10 2D    # bipush 45          # 45
B0       # return             # 
A7 00 22 # goto +34           # goto <104:endif>
# <103:else>
15 02    # vload 2            # q
13 00 0B # ildc 11            # c[11] = -24142
A3 00 06 # if_icmpgt +6       # if (q > -(24142)) goto <109:and>
A7 00 14 # goto +20           # goto <107:else>
# <109:and>
15 02    # vload 2            # q
13 00 0C # ildc 12            # c[12] = -4142
A4 00 06 # if_icmple +6       # if (q <= -(4142)) goto <106:then>
A7 00 09 # goto +9            # goto <107:else>
# <106:then>
10 D3    # bipush -45         # -45
B0       # return             # 
A7 00 06 # goto +6            # goto <108:endif>
# <107:else>
10 5A    # bipush 90          # 90
B0       # return             # 
# <108:endif>
# <104:endif>
# <100:endif>


#<mask_main>
04                # number of arguments = 4
18                # number of local variables = 24
04 FF             # code length = 1279 bytes
14 01 3D # aldc 317           # s[317] = "Input image:  "
B7 00 03 # invokenative 3     # print("Input image:  ")
57       # pop                # (ignore result)
15 00    # vload 0            # input
B7 00 03 # invokenative 3     # print(input)
57       # pop                # (ignore result)
14 01 4C # aldc 332           # s[332] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
14 01 4E # aldc 334           # s[334] = "Output image: "
B7 00 03 # invokenative 3     # print("Output image: ")
57       # pop                # (ignore result)
15 01    # vload 1            # output
B7 00 03 # invokenative 3     # print(output)
57       # pop                # (ignore result)
14 01 5D # aldc 349           # s[349] = "\n\n"
B7 00 03 # invokenative 3     # print("\n\n")
57       # pop                # (ignore result)
15 00    # vload 0            # input
B7 00 07 # invokenative 7     # image_load(input)
36 04    # vstore 4           # source = image_load(input);
15 04    # vload 4            # source
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (source == NULL) goto <110:then>
A7 00 0A # goto +10           # goto <111:else>
# <110:then>
14 01 60 # aldc 352           # s[352] = "Could not load source image"
BF       # athrow             # error "Could not load source image"
A7 00 03 # goto +3            # goto <112:endif>
# <111:else>
# <112:endif>
15 04    # vload 4            # source
B7 00 08 # invokenative 8     # image_width(source)
36 05    # vstore 5           # width = image_width(source);
15 04    # vload 4            # source
B7 00 09 # invokenative 9     # image_height(source)
36 06    # vstore 6           # height = image_height(source);
15 04    # vload 4            # source
B7 00 0A # invokenative 10    # image_data(source)
36 07    # vstore 7           # inpixels = image_data(source);
14 01 7C # aldc 380           # s[380] = "Loaded image.  Dimensions are "
B7 00 03 # invokenative 3     # print("Loaded image.  Dimensions are ")
57       # pop                # (ignore result)
15 05    # vload 5            # width
B7 00 06 # invokenative 6     # printint(width)
57       # pop                # (ignore result)
14 01 9B # aldc 411           # s[411] = " by "
B7 00 03 # invokenative 3     # print(" by ")
57       # pop                # (ignore result)
15 06    # vload 6            # height
B7 00 06 # invokenative 6     # printint(height)
57       # pop                # (ignore result)
14 01 A0 # aldc 416           # s[416] = ".\n"
B7 00 03 # invokenative 3     # print(".\n")
57       # pop                # (ignore result)
15 03    # vload 3            # nmasks
BC 08    # newarray 8         # alloc_array(int[], nmasks)
36 08    # vstore 8           # maskdata = alloc_array(int[], nmasks);
15 03    # vload 3            # nmasks
BC 04    # newarray 4         # alloc_array(int, nmasks)
36 09    # vstore 9           # masksize = alloc_array(int, nmasks);
15 03    # vload 3            # nmasks
BC 04    # newarray 4         # alloc_array(int, nmasks)
36 0A    # vstore 10          # masksum = alloc_array(int, nmasks);
10 00    # bipush 0           # 0
36 0B    # vstore 11          # i = 0;
# <113:loop>
15 0B    # vload 11           # i
15 03    # vload 3            # nmasks
A1 00 06 # if_icmplt +6       # if (i < nmasks) goto <114:body>
A7 01 0E # goto +270          # goto <115:exit>
# <114:body>
15 02    # vload 2            # masks
15 0B    # vload 11           # i
63       # aadds              # &masks[i]
2F       # amload             # masks[i]
B7 00 0B # invokenative 11    # file_read(masks[i])
36 0C    # vstore 12          # file = file_read(masks[i]);
10 00    # bipush 0           # 0
36 0D    # vstore 13          # tmp = 0;
15 0C    # vload 12           # file
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (file == NULL) goto <116:then>
A7 00 0A # goto +10           # goto <117:else>
# <116:then>
14 01 A3 # aldc 419           # s[419] = "Unable to read mask file. Try again."
BF       # athrow             # error "Unable to read mask file. Try again."
A7 00 03 # goto +3            # goto <118:endif>
# <117:else>
# <118:endif>
15 0C    # vload 12           # file
B7 00 0D # invokenative 13    # file_readline(file)
10 0A    # bipush 10          # 10
B7 00 0C # invokenative 12    # parse_int(file_readline(file), 10)
36 0E    # vstore 14          # size = parse_int(file_readline(file), 10);
15 0E    # vload 14           # size
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (size == NULL) goto <119:then>
A7 00 0A # goto +10           # goto <120:else>
# <119:then>
14 01 C8 # aldc 456           # s[456] = "Invalid blur mask size"
BF       # athrow             # error "Invalid blur mask size"
A7 00 03 # goto +3            # goto <121:endif>
# <120:else>
# <121:endif>
15 0E    # vload 14           # size
01       # aconst_null        # NULL
9F 00 1F # if_cmpeq +31       # if (size == NULL) goto <122:then>
A7 00 03 # goto +3            # goto <126:or>
# <126:or>
15 0E    # vload 14           # size
2E       # imload             # *(size)
10 00    # bipush 0           # 0
A1 00 14 # if_icmplt +20      # if (*(size) < 0) goto <122:then>
A7 00 03 # goto +3            # goto <125:or>
# <125:or>
15 0E    # vload 14           # size
2E       # imload             # *(size)
10 02    # bipush 2           # 2
70       # irem               # (*(size) % 2)
10 01    # bipush 1           # 1
A0 00 06 # if_cmpne +6        # if ((*(size) % 2) != 1) goto <122:then>
A7 00 0A # goto +10           # goto <123:else>
# <122:then>
14 01 DF # aldc 479           # s[479] = "Invalid blur mask size"
BF       # athrow             # error "Invalid blur mask size"
A7 00 03 # goto +3            # goto <124:endif>
# <123:else>
# <124:endif>
15 08    # vload 8            # maskdata
15 0B    # vload 11           # i
63       # aadds              # &maskdata[i]
15 0E    # vload 14           # size
2E       # imload             # *(size)
15 0E    # vload 14           # size
2E       # imload             # *(size)
68       # imul               # (*(size) * *(size))
BC 04    # newarray 4         # alloc_array(int, (*(size) * *(size)))
4F       # amstore            # maskdata[i] = alloc_array(int, (*(size) * *(size)));
10 00    # bipush 0           # 0
36 0F    # vstore 15          # j = 0;
# <127:loop>
15 0C    # vload 12           # file
B7 00 0E # invokenative 14    # file_eof(file)
10 01    # bipush 1           # true
9F 00 5C # if_cmpeq +92       # if (file_eof(file) == true) goto <129:exit>
A7 00 03 # goto +3            # goto <128:body>
# <128:body>
15 0C    # vload 12           # file
B7 00 0D # invokenative 13    # file_readline(file)
10 0A    # bipush 10          # 10
B7 00 0C # invokenative 12    # parse_int(file_readline(file), 10)
36 10    # vstore 16          # value = parse_int(file_readline(file), 10);
15 10    # vload 16           # value
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (value == NULL) goto <130:then>
A7 00 25 # goto +37           # goto <131:else>
# <130:then>
14 01 F6 # aldc 502           # s[502] = "Line "
B7 00 03 # invokenative 3     # print("Line ")
57       # pop                # (ignore result)
15 0F    # vload 15           # j
10 02    # bipush 2           # 2
60       # iadd               # (j + 2)
B7 00 06 # invokenative 6     # printint((j + 2))
57       # pop                # (ignore result)
14 01 FC # aldc 508           # s[508] = ""
B7 00 03 # invokenative 3     # print("")
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
14 01 FD # aldc 509           # s[509] = " has invalid weight"
BF       # athrow             # error " has invalid weight"
A7 00 03 # goto +3            # goto <132:endif>
# <131:else>
# <132:endif>
15 08    # vload 8            # maskdata
15 0B    # vload 11           # i
63       # aadds              # &maskdata[i]
2F       # amload             # maskdata[i]
15 0F    # vload 15           # j
63       # aadds              # &maskdata[i][j]
15 10    # vload 16           # value
2E       # imload             # *(value)
4E       # imstore            # maskdata[i][j] = *(value);
15 0D    # vload 13           # tmp
15 10    # vload 16           # value
2E       # imload             # *(value)
60       # iadd               # 
36 0D    # vstore 13          # tmp += *(value);
15 0F    # vload 15           # j
10 01    # bipush 1           # 1
60       # iadd               # 
36 0F    # vstore 15          # j += 1;
A7 FF A0 # goto -96           # goto <127:loop>
# <129:exit>
15 0F    # vload 15           # j
15 0E    # vload 14           # size
2E       # imload             # *(size)
15 0E    # vload 14           # size
2E       # imload             # *(size)
68       # imul               # (*(size) * *(size))
A0 00 06 # if_cmpne +6        # if (j != (*(size) * *(size))) goto <133:then>
A7 00 0A # goto +10           # goto <134:else>
# <133:then>
14 02 11 # aldc 529           # s[529] = "Not enough weights in mask file"
BF       # athrow             # error "Not enough weights in mask file"
A7 00 03 # goto +3            # goto <135:endif>
# <134:else>
# <135:endif>
15 09    # vload 9            # masksize
15 0B    # vload 11           # i
63       # aadds              # &masksize[i]
15 0E    # vload 14           # size
2E       # imload             # *(size)
4E       # imstore            # masksize[i] = *(size);
15 0A    # vload 10           # masksum
15 0B    # vload 11           # i
63       # aadds              # &masksum[i]
15 0D    # vload 13           # tmp
4E       # imstore            # masksum[i] = tmp;
15 0B    # vload 11           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0B    # vstore 11          # i += 1;
A7 FE EE # goto -274          # goto <113:loop>
# <115:exit>
14 02 31 # aldc 561           # s[561] = "Running blur..."
B7 00 03 # invokenative 3     # print("Running blur...")
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
15 07    # vload 7            # inpixels
15 05    # vload 5            # width
15 06    # vload 6            # height
15 08    # vload 8            # maskdata
10 00    # bipush 0           # 0
63       # aadds              # &maskdata[0]
2F       # amload             # maskdata[0]
15 09    # vload 9            # masksize
10 00    # bipush 0           # 0
63       # aadds              # &masksize[0]
2E       # imload             # masksize[0]
B8 00 16 # invokestatic 22    # apply_mask(inpixels, width, height, maskdata[0], masksize[0])
36 0B    # vstore 11          # blurval = apply_mask(inpixels, width, height, maskdata[0], masksize[0]);
14 02 41 # aldc 577           # s[577] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
15 05    # vload 5            # width
15 06    # vload 6            # height
68       # imul               # (width * height)
BC 04    # newarray 4         # alloc_array(pixel_t, (width * height))
36 0C    # vstore 12          # blurpix = alloc_array(pixel_t, (width * height));
10 00    # bipush 0           # 0
36 0D    # vstore 13          # i = 0;
# <136:loop>
15 0D    # vload 13           # i
15 05    # vload 5            # width
15 06    # vload 6            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (i < (width * height)) goto <137:body>
A7 00 3B # goto +59           # goto <138:exit>
# <137:body>
15 0B    # vload 11           # blurval
15 0D    # vload 13           # i
63       # aadds              # &blurval[i]
2E       # imload             # blurval[i]
15 0A    # vload 10           # masksum
10 00    # bipush 0           # 0
63       # aadds              # &masksum[0]
2E       # imload             # masksum[0]
6C       # idiv               # (blurval[i] / masksum[0])
36 0E    # vstore 14          # tmp = (blurval[i] / masksum[0]);
15 0C    # vload 12           # blurpix
15 0D    # vload 13           # i
63       # aadds              # &blurpix[i]
15 07    # vload 7            # inpixels
15 0D    # vload 13           # i
63       # aadds              # &inpixels[i]
2E       # imload             # inpixels[i]
13 00 0D # ildc 13            # c[13] = -16777216
7E       # iand               # (inpixels[i] & -(16777216))
15 0E    # vload 14           # tmp
10 10    # bipush 16          # 16
78       # ishl               # (tmp << 16)
80       # ior                # ((inpixels[i] & -(16777216)) | (tmp << 16))
15 0E    # vload 14           # tmp
10 08    # bipush 8           # 8
78       # ishl               # (tmp << 8)
80       # ior                # (((inpixels[i] & -(16777216)) | (tmp << 16)) | (tmp << 8))
15 0E    # vload 14           # tmp
80       # ior                # ((((inpixels[i] & -(16777216)) | (tmp << 16)) | (tmp << 8)) | tmp)
4E       # imstore            # blurpix[i] = ((((inpixels[i] & -(16777216)) | (tmp << 16)) | (tmp << 8)) | tmp);
15 0D    # vload 13           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0D    # vstore 13          # i += 1;
A7 FF BE # goto -66           # goto <136:loop>
# <138:exit>
14 02 48 # aldc 584           # s[584] = "Running Sobel Operator X..."
B7 00 03 # invokenative 3     # print("Running Sobel Operator X...")
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
15 0C    # vload 12           # blurpix
15 05    # vload 5            # width
15 06    # vload 6            # height
15 08    # vload 8            # maskdata
10 01    # bipush 1           # 1
63       # aadds              # &maskdata[1]
2F       # amload             # maskdata[1]
15 09    # vload 9            # masksize
10 01    # bipush 1           # 1
63       # aadds              # &masksize[1]
2E       # imload             # masksize[1]
B8 00 16 # invokestatic 22    # apply_mask(blurpix, width, height, maskdata[1], masksize[1])
36 0D    # vstore 13          # sobelX = apply_mask(blurpix, width, height, maskdata[1], masksize[1]);
14 02 64 # aldc 612           # s[612] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
14 02 6B # aldc 619           # s[619] = "Running Sobel Operator Y..."
B7 00 03 # invokenative 3     # print("Running Sobel Operator Y...")
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
15 0C    # vload 12           # blurpix
15 05    # vload 5            # width
15 06    # vload 6            # height
15 08    # vload 8            # maskdata
10 02    # bipush 2           # 2
63       # aadds              # &maskdata[2]
2F       # amload             # maskdata[2]
15 09    # vload 9            # masksize
10 02    # bipush 2           # 2
63       # aadds              # &masksize[2]
2E       # imload             # masksize[2]
B8 00 16 # invokestatic 22    # apply_mask(blurpix, width, height, maskdata[2], masksize[2])
36 0E    # vstore 14          # sobelY = apply_mask(blurpix, width, height, maskdata[2], masksize[2]);
14 02 87 # aldc 647           # s[647] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
15 05    # vload 5            # width
15 06    # vload 6            # height
68       # imul               # (width * height)
BC 04    # newarray 4         # alloc_array(int, (width * height))
36 0F    # vstore 15          # G = alloc_array(int, (width * height));
10 00    # bipush 0           # 0
36 10    # vstore 16          # i = 0;
# <139:loop>
15 10    # vload 16           # i
15 05    # vload 5            # width
15 06    # vload 6            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (i < (width * height)) goto <140:body>
A7 00 31 # goto +49           # goto <141:exit>
# <140:body>
15 0F    # vload 15           # G
15 10    # vload 16           # i
63       # aadds              # &G[i]
15 0E    # vload 14           # sobelY
15 10    # vload 16           # i
63       # aadds              # &sobelY[i]
2E       # imload             # sobelY[i]
15 0E    # vload 14           # sobelY
15 10    # vload 16           # i
63       # aadds              # &sobelY[i]
2E       # imload             # sobelY[i]
68       # imul               # (sobelY[i] * sobelY[i])
15 0D    # vload 13           # sobelX
15 10    # vload 16           # i
63       # aadds              # &sobelX[i]
2E       # imload             # sobelX[i]
15 0D    # vload 13           # sobelX
15 10    # vload 16           # i
63       # aadds              # &sobelX[i]
2E       # imload             # sobelX[i]
68       # imul               # (sobelX[i] * sobelX[i])
60       # iadd               # ((sobelY[i] * sobelY[i]) + (sobelX[i] * sobelX[i]))
B8 00 17 # invokestatic 23    # isqrt(((sobelY[i] * sobelY[i]) + (sobelX[i] * sobelX[i])))
4E       # imstore            # G[i] = isqrt(((sobelY[i] * sobelY[i]) + (sobelX[i] * sobelX[i])));
15 10    # vload 16           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 10    # vstore 16          # i += 1;
A7 FF C8 # goto -56           # goto <139:loop>
# <141:exit>
15 05    # vload 5            # width
15 06    # vload 6            # height
B7 00 10 # invokenative 16    # image_create(width, height)
36 10    # vstore 16          # dest = image_create(width, height);
15 10    # vload 16           # dest
B7 00 0A # invokenative 10    # image_data(dest)
36 11    # vstore 17          # outpixels = image_data(dest);
10 00    # bipush 0           # 0
36 12    # vstore 18          # i = 0;
# <142:loop>
15 12    # vload 18           # i
15 06    # vload 6            # height
A1 00 06 # if_icmplt +6       # if (i < height) goto <143:body>
A7 02 0E # goto +526          # goto <144:exit>
# <143:body>
10 00    # bipush 0           # 0
36 13    # vstore 19          # j = 0;
# <145:loop>
15 13    # vload 19           # j
15 05    # vload 5            # width
A1 00 06 # if_icmplt +6       # if (j < width) goto <146:body>
A7 01 F6 # goto +502          # goto <147:exit>
# <146:body>
10 01    # bipush 1           # 1
36 14    # vstore 20          # s = 1;
10 01    # bipush 1           # 1
36 15    # vstore 21          # t = 1;
15 12    # vload 18           # i
15 13    # vload 19           # j
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index(i, j, width, height)
36 16    # vstore 22          # index = get_index(i, j, width, height);
15 0E    # vload 14           # sobelY
15 16    # vload 22           # index
63       # aadds              # &sobelY[index]
2E       # imload             # sobelY[index]
15 0D    # vload 13           # sobelX
15 16    # vload 22           # index
63       # aadds              # &sobelX[index]
2E       # imload             # sobelX[index]
B8 00 18 # invokestatic 24    # direction(sobelY[index], sobelX[index])
36 17    # vstore 23          # D = direction(sobelY[index], sobelX[index]);
15 12    # vload 18           # i
10 00    # bipush 0           # 0
9F 00 2A # if_cmpeq +42       # if (i == 0) goto <148:then>
A7 00 03 # goto +3            # goto <153:or>
# <153:or>
15 13    # vload 19           # j
10 00    # bipush 0           # 0
9F 00 20 # if_cmpeq +32       # if (j == 0) goto <148:then>
A7 00 03 # goto +3            # goto <152:or>
# <152:or>
15 12    # vload 18           # i
15 06    # vload 6            # height
10 01    # bipush 1           # 1
64       # isub               # (height - 1)
9F 00 13 # if_cmpeq +19       # if (i == (height - 1)) goto <148:then>
A7 00 03 # goto +3            # goto <151:or>
# <151:or>
15 13    # vload 19           # j
15 05    # vload 5            # width
10 01    # bipush 1           # 1
64       # isub               # (width - 1)
9F 00 06 # if_cmpeq +6        # if (j == (width - 1)) goto <148:then>
A7 00 0F # goto +15           # goto <149:else>
# <148:then>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
13 00 0E # ildc 14            # c[14] = -16777216
4E       # imstore            # outpixels[index] = -(16777216);
A7 01 8C # goto +396          # goto <150:endif>
# <149:else>
15 17    # vload 23           # D
10 00    # bipush 0           # 0
9F 00 06 # if_cmpeq +6        # if (D == 0) goto <158:and>
A7 00 56 # goto +86           # goto <155:else>
# <158:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
15 13    # vload 19           # j
10 01    # bipush 1           # 1
64       # isub               # (j - 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index(i, (j - 1), width, height)
63       # aadds              # &G[get_index(i, (j - 1), width, height)]
2E       # imload             # G[get_index(i, (j - 1), width, height)]
68       # imul               # (t * G[get_index(i, (j - 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index(i, (j - 1), width, height)])) goto <157:and>
A7 00 32 # goto +50           # goto <155:else>
# <157:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
15 13    # vload 19           # j
10 01    # bipush 1           # 1
60       # iadd               # (j + 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index(i, (j + 1), width, height)
63       # aadds              # &G[get_index(i, (j + 1), width, height)]
2E       # imload             # G[get_index(i, (j + 1), width, height)]
68       # imul               # (t * G[get_index(i, (j + 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index(i, (j + 1), width, height)])) goto <154:then>
A7 00 0E # goto +14           # goto <155:else>
# <154:then>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
10 FF    # bipush -1          # -1
4E       # imstore            # outpixels[index] = -(1);
A7 01 2F # goto +303          # goto <156:endif>
# <155:else>
15 17    # vload 23           # D
10 5A    # bipush 90          # 90
9F 00 06 # if_cmpeq +6        # if (D == 90) goto <163:and>
A7 00 56 # goto +86           # goto <160:else>
# <163:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
64       # isub               # (i - 1)
15 13    # vload 19           # j
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i - 1), j, width, height)
63       # aadds              # &G[get_index((i - 1), j, width, height)]
2E       # imload             # G[get_index((i - 1), j, width, height)]
68       # imul               # (t * G[get_index((i - 1), j, width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i - 1), j, width, height)])) goto <162:and>
A7 00 32 # goto +50           # goto <160:else>
# <162:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
60       # iadd               # (i + 1)
15 13    # vload 19           # j
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i + 1), j, width, height)
63       # aadds              # &G[get_index((i + 1), j, width, height)]
2E       # imload             # G[get_index((i + 1), j, width, height)]
68       # imul               # (t * G[get_index((i + 1), j, width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i + 1), j, width, height)])) goto <159:then>
A7 00 0E # goto +14           # goto <160:else>
# <159:then>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
10 FF    # bipush -1          # -1
4E       # imstore            # outpixels[index] = -(1);
A7 00 D2 # goto +210          # goto <161:endif>
# <160:else>
15 17    # vload 23           # D
10 2D    # bipush 45          # 45
9F 00 06 # if_cmpeq +6        # if (D == 45) goto <168:and>
A7 00 5C # goto +92           # goto <165:else>
# <168:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
64       # isub               # (i - 1)
15 13    # vload 19           # j
10 01    # bipush 1           # 1
64       # isub               # (j - 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i - 1), (j - 1), width, height)
63       # aadds              # &G[get_index((i - 1), (j - 1), width, height)]
2E       # imload             # G[get_index((i - 1), (j - 1), width, height)]
68       # imul               # (t * G[get_index((i - 1), (j - 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i - 1), (j - 1), width, height)])) goto <167:and>
A7 00 35 # goto +53           # goto <165:else>
# <167:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
60       # iadd               # (i + 1)
15 13    # vload 19           # j
10 01    # bipush 1           # 1
60       # iadd               # (j + 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i + 1), (j + 1), width, height)
63       # aadds              # &G[get_index((i + 1), (j + 1), width, height)]
2E       # imload             # G[get_index((i + 1), (j + 1), width, height)]
68       # imul               # (t * G[get_index((i + 1), (j + 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i + 1), (j + 1), width, height)])) goto <164:then>
A7 00 0E # goto +14           # goto <165:else>
# <164:then>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
10 FF    # bipush -1          # -1
4E       # imstore            # outpixels[index] = -(1);
A7 00 6F # goto +111          # goto <166:endif>
# <165:else>
15 17    # vload 23           # D
10 D3    # bipush -45         # -45
9F 00 06 # if_cmpeq +6        # if (D == -(45)) goto <173:and>
A7 00 5C # goto +92           # goto <170:else>
# <173:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
60       # iadd               # (i + 1)
15 13    # vload 19           # j
10 01    # bipush 1           # 1
64       # isub               # (j - 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i + 1), (j - 1), width, height)
63       # aadds              # &G[get_index((i + 1), (j - 1), width, height)]
2E       # imload             # G[get_index((i + 1), (j - 1), width, height)]
68       # imul               # (t * G[get_index((i + 1), (j - 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i + 1), (j - 1), width, height)])) goto <172:and>
A7 00 35 # goto +53           # goto <170:else>
# <172:and>
15 14    # vload 20           # s
15 0F    # vload 15           # G
15 16    # vload 22           # index
63       # aadds              # &G[index]
2E       # imload             # G[index]
68       # imul               # (s * G[index])
15 15    # vload 21           # t
15 0F    # vload 15           # G
15 12    # vload 18           # i
10 01    # bipush 1           # 1
64       # isub               # (i - 1)
15 13    # vload 19           # j
10 01    # bipush 1           # 1
60       # iadd               # (j + 1)
15 05    # vload 5            # width
15 06    # vload 6            # height
B8 00 13 # invokestatic 19    # get_index((i - 1), (j + 1), width, height)
63       # aadds              # &G[get_index((i - 1), (j + 1), width, height)]
2E       # imload             # G[get_index((i - 1), (j + 1), width, height)]
68       # imul               # (t * G[get_index((i - 1), (j + 1), width, height)])
A3 00 06 # if_icmpgt +6       # if ((s * G[index]) > (t * G[get_index((i - 1), (j + 1), width, height)])) goto <169:then>
A7 00 0E # goto +14           # goto <170:else>
# <169:then>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
10 FF    # bipush -1          # -1
4E       # imstore            # outpixels[index] = -(1);
A7 00 0C # goto +12           # goto <171:endif>
# <170:else>
15 11    # vload 17           # outpixels
15 16    # vload 22           # index
63       # aadds              # &outpixels[index]
13 00 0F # ildc 15            # c[15] = -16777216
4E       # imstore            # outpixels[index] = -(16777216);
# <171:endif>
# <166:endif>
# <161:endif>
# <156:endif>
# <150:endif>
15 13    # vload 19           # j
10 01    # bipush 1           # 1
60       # iadd               # 
36 13    # vstore 19          # j += 1;
A7 FE 06 # goto -506          # goto <145:loop>
# <147:exit>
15 12    # vload 18           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 12    # vstore 18          # i += 1;
A7 FD EE # goto -530          # goto <142:loop>
# <144:exit>
14 02 8E # aldc 654           # s[654] = "Saving output..."
B7 00 03 # invokenative 3     # print("Saving output...")
57       # pop                # (ignore result)
B7 00 0F # invokenative 15    # flush()
57       # pop                # (ignore result)
15 10    # vload 16           # dest
15 01    # vload 1            # output
B7 00 11 # invokenative 17    # image_save(dest, output)
57       # pop                # (ignore result)
14 02 9F # aldc 671           # s[671] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<default_output>
02                # number of arguments = 2
04                # number of local variables = 4
00 60             # code length = 96 bytes
15 00    # vload 0            # input
B7 00 12 # invokenative 18    # string_length(input)
36 02    # vstore 2           # len = string_length(input);
15 02    # vload 2            # len
10 04    # bipush 4           # 4
A3 00 06 # if_icmpgt +6       # if (len > 4) goto <177:and>
A7 00 1D # goto +29           # goto <174:then>
# <177:and>
14 02 A6 # aldc 678           # s[678] = ".png"
15 00    # vload 0            # input
15 02    # vload 2            # len
10 04    # bipush 4           # 4
64       # isub               # (len - 4)
15 02    # vload 2            # len
B7 00 13 # invokenative 19    # string_sub(input, (len - 4), len)
B7 00 05 # invokenative 5     # string_equal(".png", string_sub(input, (len - 4), len))
10 01    # bipush 1           # true
9F 00 0D # if_cmpeq +13       # if (string_equal(".png", string_sub(input, (len - 4), len)) == true) goto <175:else>
A7 00 03 # goto +3            # goto <174:then>
# <174:then>
14 02 AB # aldc 683           # s[683] = "Input file does not end with .png"
BF       # athrow             # error "Input file does not end with .png"
A7 00 03 # goto +3            # goto <176:endif>
# <175:else>
# <176:endif>
15 00    # vload 0            # input
10 00    # bipush 0           # 0
15 02    # vload 2            # len
10 04    # bipush 4           # 4
64       # isub               # (len - 4)
B7 00 13 # invokenative 19    # string_sub(input, 0, (len - 4))
36 03    # vstore 3           # res = string_sub(input, 0, (len - 4));
15 03    # vload 3            # res
14 02 CD # aldc 717           # s[717] = "_"
B7 00 14 # invokenative 20    # string_join(res, "_")
36 03    # vstore 3           # res = string_join(res, "_");
15 03    # vload 3            # res
15 01    # vload 1            # name
B7 00 14 # invokenative 20    # string_join(res, name)
36 03    # vstore 3           # res = string_join(res, name);
15 03    # vload 3            # res
14 02 CF # aldc 719           # s[719] = ".png"
B7 00 14 # invokenative 20    # string_join(res, ".png")
36 03    # vstore 3           # res = string_join(res, ".png");
15 03    # vload 3            # res
B0       # return             # 

00 17             # native count
# native pool
00 01 00 5B       # char_chr
00 01 00 5C       # char_ord
00 01 00 60       # string_from_chararray
00 01 00 06       # print
00 00 00 0B       # readline
00 02 00 5F       # string_equal
00 01 00 09       # printint
00 01 00 51       # image_load
00 01 00 54       # image_width
00 01 00 50       # image_height
00 01 00 4F       # image_data
00 01 00 41       # file_read
00 02 00 58       # parse_int
00 01 00 42       # file_readline
00 01 00 40       # file_eof
00 00 00 05       # flush
00 02 00 4E       # image_create
00 02 00 52       # image_save
00 01 00 65       # string_length
00 03 00 66       # string_sub
00 02 00 64       # string_join
00 02 00 03       # args_string
00 00 00 02       # args_parse

