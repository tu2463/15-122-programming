C0 C0 FF EE       # magic number
00 17             # version 11, arch = 1 (64 bits)

00 0B             # int pool count
# int pool
7F FF FF FF
80 00 00 00
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 00 FF
00 00 00 FF
FF FF FF 01
00 00 00 FF
FF 00 00 00

03 1D             # string pool total size
# string pool
00  # ""
00  # ""
70 72 69 6E 74 5F 69 6D 61 67 65 20 69 73 20 6E 6F 74 20 61 20 75 73 65 66 75 6C 20 64 65 62 75 67 67 69 6E 67 20 74 6F 6F 6C 20 66 6F 72 20 6C 61 72 67 65 20 69 6D 61 67 65 73 0A 00  # "print_image is not a useful debugging tool for large images\n"
74 79 70 65 20 27 79 27 20 74 6F 20 70 72 6F 63 65 65 64 20 6E 6F 6E 65 74 68 65 6C 65 73 73 2C 20 00  # "type \'y\' to proceed nonetheless, "
61 6E 64 20 61 6E 79 74 68 69 6E 67 20 65 6C 73 65 20 74 6F 20 73 6B 69 70 20 70 72 69 6E 74 69 6E 67 3A 20 00  # "and anything else to skip printing: "
79 00  # "y"
59 00  # "Y"
20 00  # " "
0A 00  # "\n"
6D 61 73 6B 2E 63 30 3A 20 32 31 2E 35 2D 32 31 2E 37 34 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 21.5-21.74: assert failed"
6D 61 73 6B 2E 63 30 3A 20 32 34 2E 35 2D 32 34 2E 36 37 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 24.5-24.67: assert failed"
6D 61 73 6B 2E 63 30 3A 20 35 39 2E 31 33 2D 35 39 2E 35 39 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 59.13-59.59: assert failed"
6D 61 73 6B 2E 63 30 3A 20 36 30 2E 31 33 2D 36 30 2E 35 39 3A 20 61 73 73 65 72 74 20 66 61 69 6C 65 64 00  # "mask.c0: 60.13-60.59: assert failed"
69 3D 00  # "i="
2C 20 6C 69 6D 69 74 3D 00  # ", limit="
2C 20 63 61 6C 6C 69 6E 67 20 63 61 6C 63 75 6C 61 74 65 0A 00  # ", calling calculate\n"
49 6E 70 75 74 20 69 6D 61 67 65 20 66 69 6C 65 3A 20 20 00  # "Input image file:  "
0A 00  # "\n"
4F 75 74 70 75 74 20 69 6D 61 67 65 20 66 69 6C 65 3A 20 00  # "Output image file: "
0A 00  # "\n"
42 6C 75 72 20 6D 61 73 6B 20 66 69 6C 65 3A 20 20 20 20 00  # "Blur mask file:    "
0A 0A 00  # "\n\n"
43 6F 75 6C 64 20 6E 6F 74 20 6C 6F 61 64 20 73 6F 75 72 63 65 20 69 6D 61 67 65 00  # "Could not load source image"
4C 6F 61 64 65 64 20 69 6D 61 67 65 2E 20 20 44 69 6D 65 6E 73 69 6F 6E 73 20 61 72 65 20 00  # "Loaded image.  Dimensions are "
20 62 79 20 00  # " by "
2E 0A 00  # ".\n"
55 6E 61 62 6C 65 20 74 6F 20 72 65 61 64 20 6D 61 73 6B 20 66 69 6C 65 2E 20 54 72 79 20 61 67 61 69 6E 2E 00  # "Unable to read mask file. Try again."
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
4D 61 73 6B 20 57 69 64 74 68 3A 20 00  # "Mask Width: "
0A 00  # "\n"
49 6E 76 61 6C 69 64 20 62 6C 75 72 20 6D 61 73 6B 20 73 69 7A 65 00  # "Invalid blur mask size"
49 6E 76 61 6C 69 64 20 77 65 69 67 68 74 20 6F 6E 20 6C 69 6E 65 20 00  # "Invalid weight on line "
49 6E 63 6F 72 72 65 63 74 20 6E 75 6D 62 65 72 20 6F 66 20 77 65 69 67 68 74 73 20 69 6E 20 6D 61 73 6B 20 66 69 6C 65 00  # "Incorrect number of weights in mask file"
41 70 70 6C 79 69 6E 67 20 6D 61 73 6B 2E 2E 2E 00  # "Applying mask..."
64 6F 6E 65 2E 0A 00  # "done.\n"
53 61 76 69 6E 67 20 6F 75 74 70 75 74 2E 2E 2E 00  # "Saving output..."
64 6F 6E 65 2E 0A 00  # "done.\n"
2E 70 6E 67 00  # ".png"
49 6E 70 75 74 20 66 69 6C 65 20 64 6F 65 73 20 6E 6F 74 20 65 6E 64 20 77 69 74 68 20 2E 70 6E 67 00  # "Input file does not end with .png"
5F 00  # "_"
2E 70 6E 67 00  # ".png"
2D 6F 00  # "-o"
2D 69 00  # "-i"
2D 6D 00  # "-m"
00  # ""
00  # ""
55 73 61 67 65 3A 20 6D 61 73 6B 62 6C 75 72 20 2D 69 20 3C 69 6E 70 75 74 20 69 6D 61 67 65 3E 20 2D 6D 20 3C 62 6C 75 72 20 6D 61 73 6B 3E 00  # "Usage: maskblur -i <input image> -m <blur mask>"
5B 2D 6F 20 3C 6F 75 74 70 75 74 20 69 6D 61 67 65 3E 5D 00  # "[-o <output image>]"
00  # ""
6D 61 73 6B 62 6C 75 72 00  # "maskblur"

00 19             # function count
# function_pool

#<main>
00                # number of arguments = 0
03                # number of local variables = 3
00 8A             # code length = 138 bytes
BB 08    # new 8              # alloc(string)
36 00    # vstore 0           # output = alloc(string);
BB 08    # new 8              # alloc(string)
36 01    # vstore 1           # input = alloc(string);
BB 08    # new 8              # alloc(string)
36 02    # vstore 2           # mask = alloc(string);
14 02 C4 # aldc 708           # s[708] = "-o"
15 00    # vload 0            # output
B7 00 16 # invokenative 22    # args_string("-o", output)
57       # pop                # (ignore result)
14 02 C7 # aldc 711           # s[711] = "-i"
15 01    # vload 1            # input
B7 00 16 # invokenative 22    # args_string("-i", input)
57       # pop                # (ignore result)
14 02 CA # aldc 714           # s[714] = "-m"
15 02    # vload 2            # mask
B7 00 16 # invokenative 22    # args_string("-m", mask)
57       # pop                # (ignore result)
B7 00 17 # invokenative 23    # args_parse()
57       # pop                # (ignore result)
14 02 CD # aldc 717           # s[717] = ""
15 01    # vload 1            # input
2F       # amload             # *(input)
B7 00 05 # invokenative 5     # string_equal("", *(input))
10 01    # bipush 1           # true
9F 00 17 # if_cmpeq +23       # if (string_equal("", *(input)) == true) goto <135:then>
A7 00 03 # goto +3            # goto <138:or>
# <138:or>
14 02 CE # aldc 718           # s[718] = ""
15 02    # vload 2            # mask
2F       # amload             # *(mask)
B7 00 05 # invokenative 5     # string_equal("", *(mask))
10 01    # bipush 1           # true
9F 00 06 # if_cmpeq +6        # if (string_equal("", *(mask)) == true) goto <135:then>
A7 00 10 # goto +16           # goto <136:else>
# <135:then>
14 02 CF # aldc 719           # s[719] = "Usage: maskblur -i <input image> -m <blur mask>"
14 02 FF # aldc 767           # s[767] = "[-o <output image>]"
B7 00 0F # invokenative 15    # string_join("Usage: maskblur -i <input image> -m <blur mask>", "[-o <output image>]")
BF       # athrow             # error string_join("Usage: maskblur -i <input image> -m <blur mask>", "[-o <output image>]")
A7 00 03 # goto +3            # goto <137:endif>
# <136:else>
# <137:endif>
14 03 13 # aldc 787           # s[787] = ""
15 00    # vload 0            # output
2F       # amload             # *(output)
B7 00 05 # invokenative 5     # string_equal("", *(output))
10 01    # bipush 1           # true
9F 00 06 # if_cmpeq +6        # if (string_equal("", *(output)) == true) goto <139:then>
A7 00 12 # goto +18           # goto <140:else>
# <139:then>
15 00    # vload 0            # output
15 01    # vload 1            # input
2F       # amload             # *(input)
14 03 14 # aldc 788           # s[788] = "maskblur"
B8 00 18 # invokestatic 24    # default_output(*(input), "maskblur")
4F       # amstore            # *(output) = default_output(*(input), "maskblur");
A7 00 03 # goto +3            # goto <141:endif>
# <140:else>
# <141:endif>
15 01    # vload 1            # input
2F       # amload             # *(input)
15 00    # vload 0            # output
2F       # amload             # *(output)
15 02    # vload 2            # mask
2F       # amload             # *(mask)
B8 00 17 # invokestatic 23    # mask_main(*(input), *(output), *(mask))
57       # pop                # (ignore result)
10 00    # bipush 0           # 0
B0       # return             # 


#<int_size>
00                # number of arguments = 0
00                # number of local variables = 0
00 03             # code length = 3 bytes
10 04    # bipush 4           # 4
B0       # return             # 


#<int_max>
00                # number of arguments = 0
00                # number of local variables = 0
00 04             # code length = 4 bytes
13 00 00 # ildc 0             # c[0] = 2147483647
B0       # return             # 


#<int_min>
00                # number of arguments = 0
00                # number of local variables = 0
00 04             # code length = 4 bytes
13 00 01 # ildc 1             # c[1] = -2147483648
B0       # return             # 


#<abs>
01                # number of arguments = 1
01                # number of local variables = 1
00 15             # code length = 21 bytes
15 00    # vload 0            # x
10 00    # bipush 0           # 0
A1 00 06 # if_icmplt +6       # if (x < 0) goto <06:cond_true>
A7 00 0B # goto +11           # goto <07:cond_false>
# <06:cond_true>
10 00    # bipush 0           # 
15 00    # vload 0            # x
64       # isub               # -(x)
A7 00 05 # goto +5            # goto <08:cond_end>
# <07:cond_false>
15 00    # vload 0            # x
# <08:cond_end>
B0       # return             # 


#<max>
02                # number of arguments = 2
02                # number of local variables = 2
00 12             # code length = 18 bytes
15 00    # vload 0            # x
15 01    # vload 1            # y
A3 00 06 # if_icmpgt +6       # if (x > y) goto <00:cond_true>
A7 00 08 # goto +8            # goto <01:cond_false>
# <00:cond_true>
15 00    # vload 0            # x
A7 00 05 # goto +5            # goto <02:cond_end>
# <01:cond_false>
15 01    # vload 1            # y
# <02:cond_end>
B0       # return             # 


#<min>
02                # number of arguments = 2
02                # number of local variables = 2
00 12             # code length = 18 bytes
15 00    # vload 0            # x
15 01    # vload 1            # y
A3 00 06 # if_icmpgt +6       # if (x > y) goto <03:cond_true>
A7 00 08 # goto +8            # goto <04:cond_false>
# <03:cond_true>
15 01    # vload 1            # y
A7 00 05 # goto +5            # goto <05:cond_end>
# <04:cond_false>
15 00    # vload 0            # x
# <05:cond_end>
B0       # return             # 


#<int2hex>
01                # number of arguments = 1
04                # number of local variables = 4
00 52             # code length = 82 bytes
10 02    # bipush 2           # 2
B8 00 01 # invokestatic 1     # int_size()
68       # imul               # (2 * int_size())
36 01    # vstore 1           # digits = (2 * int_size());
15 01    # vload 1            # digits
10 01    # bipush 1           # 1
60       # iadd               # (digits + 1)
BC 01    # newarray 1         # alloc_array(char, (digits + 1))
36 02    # vstore 2           # s = alloc_array(char, (digits + 1));
15 02    # vload 2            # s
15 01    # vload 1            # digits
63       # aadds              # &s[digits]
10 00    # bipush 0           # '\000'
55       # cmstore            # s[digits] = '\0';
10 00    # bipush 0           # 0
36 03    # vstore 3           # i = 0;
# <17:loop>
15 03    # vload 3            # i
15 01    # vload 1            # digits
A1 00 06 # if_icmplt +6       # if (i < digits) goto <18:body>
A7 00 28 # goto +40           # goto <19:exit>
# <18:body>
15 02    # vload 2            # s
15 01    # vload 1            # digits
15 03    # vload 3            # i
64       # isub               # (digits - i)
10 01    # bipush 1           # 1
64       # isub               # ((digits - i) - 1)
63       # aadds              # &s[((digits - i) - 1)]
15 00    # vload 0            # x
10 0F    # bipush 15          # 15
7E       # iand               # (x & 15)
B8 00 08 # invokestatic 8     # hexdig2char((x & 15))
55       # cmstore            # s[((digits - i) - 1)] = hexdig2char((x & 15));
15 00    # vload 0            # x
10 04    # bipush 4           # 4
7A       # ishr               # (x >> 4)
36 00    # vstore 0           # x = (x >> 4);
15 03    # vload 3            # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 03    # vstore 3           # i += 1;
A7 FF D4 # goto -44           # goto <17:loop>
# <19:exit>
15 02    # vload 2            # s
B7 00 02 # invokenative 2     # string_from_chararray(s)
B0       # return             # 


#<hexdig2char>
01                # number of arguments = 1
01                # number of local variables = 1
00 4C             # code length = 76 bytes
10 00    # bipush 0           # 0
15 00    # vload 0            # d
A4 00 06 # if_icmple +6       # if (0 <= d) goto <12:and>
A7 00 1C # goto +28           # goto <10:else>
# <12:and>
15 00    # vload 0            # d
10 0A    # bipush 10          # 10
A1 00 06 # if_icmplt +6       # if (d < 10) goto <09:then>
A7 00 12 # goto +18           # goto <10:else>
# <09:then>
10 30    # bipush 48          # '0'
B7 00 01 # invokenative 1     # char_ord('0')
15 00    # vload 0            # d
60       # iadd               # (char_ord('0') + d)
B7 00 00 # invokenative 0     # char_chr((char_ord('0') + d))
B0       # return             # 
A7 00 2C # goto +44           # goto <11:endif>
# <10:else>
10 0A    # bipush 10          # 10
15 00    # vload 0            # d
A4 00 06 # if_icmple +6       # if (10 <= d) goto <16:and>
A7 00 1F # goto +31           # goto <14:else>
# <16:and>
15 00    # vload 0            # d
10 10    # bipush 16          # 16
A1 00 06 # if_icmplt +6       # if (d < 16) goto <13:then>
A7 00 15 # goto +21           # goto <14:else>
# <13:then>
10 41    # bipush 65          # 'A'
B7 00 01 # invokenative 1     # char_ord('A')
15 00    # vload 0            # d
10 0A    # bipush 10          # 10
64       # isub               # (d - 10)
60       # iadd               # (char_ord('A') + (d - 10))
B7 00 00 # invokenative 0     # char_chr((char_ord('A') + (d - 10)))
B0       # return             # 
A7 00 06 # goto +6            # goto <15:endif>
# <14:else>
10 3F    # bipush 63          # '\?'
B0       # return             # 
# <15:endif>
# <11:endif>


#<get_red>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 02 # ildc 2             # c[2] = 255
15 00    # vload 0            # p
10 10    # bipush 16          # 16
7A       # ishr               # (p >> 16)
7E       # iand               # (255 & (p >> 16))
B0       # return             # 


#<get_green>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 03 # ildc 3             # c[3] = 255
15 00    # vload 0            # p
10 08    # bipush 8           # 8
7A       # ishr               # (p >> 8)
7E       # iand               # (255 & (p >> 8))
B0       # return             # 


#<get_blue>
01                # number of arguments = 1
01                # number of local variables = 1
00 07             # code length = 7 bytes
13 00 04 # ildc 4             # c[4] = 255
15 00    # vload 0            # p
7E       # iand               # (255 & p)
B0       # return             # 


#<get_alpha>
01                # number of arguments = 1
01                # number of local variables = 1
00 0A             # code length = 10 bytes
13 00 05 # ildc 5             # c[5] = 255
15 00    # vload 0            # p
10 18    # bipush 24          # 24
7A       # ishr               # (p >> 24)
7E       # iand               # (255 & (p >> 24))
B0       # return             # 


#<make_pixel>
04                # number of arguments = 4
04                # number of local variables = 4
00 15             # code length = 21 bytes
15 00    # vload 0            # alpha
10 18    # bipush 24          # 24
78       # ishl               # (alpha << 24)
15 01    # vload 1            # red
10 10    # bipush 16          # 16
78       # ishl               # (red << 16)
80       # ior                # ((alpha << 24) | (red << 16))
15 02    # vload 2            # green
10 08    # bipush 8           # 8
78       # ishl               # (green << 8)
80       # ior                # (((alpha << 24) | (red << 16)) | (green << 8))
15 03    # vload 3            # blue
80       # ior                # ((((alpha << 24) | (red << 16)) | (green << 8)) | blue)
B0       # return             # 


#<pixel_print>
01                # number of arguments = 1
01                # number of local variables = 1
00 1A             # code length = 26 bytes
14 00 00 # aldc 0             # s[0] = ""
B7 00 03 # invokenative 3     # print("")
57       # pop                # (ignore result)
15 00    # vload 0            # p
B8 00 07 # invokestatic 7     # int2hex(p)
B7 00 03 # invokenative 3     # print(int2hex(p))
57       # pop                # (ignore result)
14 00 01 # aldc 1             # s[1] = ""
B7 00 03 # invokenative 3     # print("")
57       # pop                # (ignore result)
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<is_valid_imagesize>
02                # number of arguments = 2
02                # number of local variables = 2
00 2F             # code length = 47 bytes
15 00    # vload 0            # width
10 00    # bipush 0           # 0
A3 00 06 # if_icmpgt +6       # if (width > 0) goto <23:and>
A7 00 25 # goto +37           # goto <21:cond_false>
# <23:and>
15 01    # vload 1            # height
10 00    # bipush 0           # 0
A3 00 06 # if_icmpgt +6       # if (height > 0) goto <20:cond_true>
A7 00 1B # goto +27           # goto <21:cond_false>
# <20:cond_true>
15 00    # vload 0            # width
B8 00 02 # invokestatic 2     # int_max()
15 01    # vload 1            # height
6C       # idiv               # (int_max() / height)
A4 00 06 # if_icmple +6       # if (width <= (int_max() / height)) goto <24:cond_true>
A7 00 08 # goto +8            # goto <25:cond_false>
# <24:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <26:cond_end>
# <25:cond_false>
10 00    # bipush 0           # false
# <26:cond_end>
A7 00 05 # goto +5            # goto <22:cond_end>
# <21:cond_false>
10 00    # bipush 0           # false
# <22:cond_end>
B0       # return             # 


#<get_row>
03                # number of arguments = 3
03                # number of local variables = 3
00 06             # code length = 6 bytes
15 00    # vload 0            # index
15 01    # vload 1            # width
6C       # idiv               # (index / width)
B0       # return             # 


#<get_column>
03                # number of arguments = 3
04                # number of local variables = 4
00 14             # code length = 20 bytes
15 00    # vload 0            # index
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 10 # invokestatic 16    # get_row(index, width, height)
36 03    # vstore 3           # row = get_row(index, width, height);
15 00    # vload 0            # index
15 03    # vload 3            # row
15 01    # vload 1            # width
68       # imul               # (row * width)
64       # isub               # (index - (row * width))
B0       # return             # 


#<is_valid_pixel>
04                # number of arguments = 4
04                # number of local variables = 4
00 69             # code length = 105 bytes
10 00    # bipush 0           # 0
15 00    # vload 0            # row
A4 00 06 # if_icmple +6       # if (0 <= row) goto <34:and>
A7 00 5F # goto +95           # goto <28:cond_false>
# <34:and>
15 00    # vload 0            # row
15 03    # vload 3            # height
A1 00 06 # if_icmplt +6       # if (row < height) goto <33:and>
A7 00 55 # goto +85           # goto <28:cond_false>
# <33:and>
10 00    # bipush 0           # 0
15 01    # vload 1            # col
A4 00 06 # if_icmple +6       # if (0 <= col) goto <32:and>
A7 00 4B # goto +75           # goto <28:cond_false>
# <32:and>
15 01    # vload 1            # col
15 02    # vload 2            # width
A1 00 06 # if_icmplt +6       # if (col < width) goto <31:and>
A7 00 41 # goto +65           # goto <28:cond_false>
# <31:and>
15 00    # vload 0            # row
B8 00 02 # invokestatic 2     # int_max()
15 01    # vload 1            # col
64       # isub               # (int_max() - col)
15 02    # vload 2            # width
6C       # idiv               # ((int_max() - col) / width)
A4 00 06 # if_icmple +6       # if (row <= ((int_max() - col) / width)) goto <30:and>
A7 00 30 # goto +48           # goto <28:cond_false>
# <30:and>
10 00    # bipush 0           # 0
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
A4 00 06 # if_icmple +6       # if (0 <= ((row * width) + col)) goto <27:cond_true>
A7 00 20 # goto +32           # goto <28:cond_false>
# <27:cond_true>
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
15 02    # vload 2            # width
15 03    # vload 3            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (((row * width) + col) < (width * height)) goto <35:cond_true>
A7 00 08 # goto +8            # goto <36:cond_false>
# <35:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <37:cond_end>
# <36:cond_false>
10 00    # bipush 0           # false
# <37:cond_end>
A7 00 05 # goto +5            # goto <29:cond_end>
# <28:cond_false>
10 00    # bipush 0           # false
# <29:cond_end>
B0       # return             # 


#<get_index>
04                # number of arguments = 4
04                # number of local variables = 4
00 09             # code length = 9 bytes
15 00    # vload 0            # row
15 02    # vload 2            # width
68       # imul               # (row * width)
15 01    # vload 1            # col
60       # iadd               # ((row * width) + col)
B0       # return             # 


#<image_print>
03                # number of arguments = 3
05                # number of local variables = 5
00 AB             # code length = 171 bytes
15 01    # vload 1            # width
10 0A    # bipush 10          # 10
A3 00 10 # if_icmpgt +16      # if (width > 10) goto <38:then>
A7 00 03 # goto +3            # goto <41:or>
# <41:or>
15 02    # vload 2            # height
10 0A    # bipush 10          # 10
A3 00 06 # if_icmpgt +6       # if (height > 10) goto <38:then>
A7 00 46 # goto +70           # goto <39:else>
# <38:then>
14 00 02 # aldc 2             # s[2] = "print_image is not a useful debugging tool for large images\n"
B7 00 03 # invokenative 3     # print("print_image is not a useful debugging tool for large images\n")
57       # pop                # (ignore result)
14 00 3F # aldc 63            # s[63] = "type \'y\' to proceed nonetheless, "
B7 00 03 # invokenative 3     # print("type \'y\' to proceed nonetheless, ")
57       # pop                # (ignore result)
14 00 61 # aldc 97            # s[97] = "and anything else to skip printing: "
B7 00 03 # invokenative 3     # print("and anything else to skip printing: ")
57       # pop                # (ignore result)
B7 00 04 # invokenative 4     # readline()
36 03    # vstore 3           # s = readline();
15 03    # vload 3            # s
14 00 86 # aldc 134           # s[134] = "y"
B7 00 05 # invokenative 5     # string_equal(s, "y")
10 01    # bipush 1           # true
9F 00 1C # if_cmpeq +28       # if (string_equal(s, "y") == true) goto <43:else>
A7 00 03 # goto +3            # goto <45:or>
# <45:or>
15 03    # vload 3            # s
14 00 88 # aldc 136           # s[136] = "Y"
B7 00 05 # invokenative 5     # string_equal(s, "Y")
10 01    # bipush 1           # true
9F 00 0C # if_cmpeq +12       # if (string_equal(s, "Y") == true) goto <43:else>
A7 00 03 # goto +3            # goto <42:then>
# <42:then>
10 00    # bipush 0           # dummy return value
B0       # return             # 
A7 00 03 # goto +3            # goto <44:endif>
# <43:else>
# <44:endif>
A7 00 03 # goto +3            # goto <40:endif>
# <39:else>
# <40:endif>
10 00    # bipush 0           # 0
36 03    # vstore 3           # row = 0;
# <46:loop>
15 03    # vload 3            # row
15 02    # vload 2            # height
A1 00 06 # if_icmplt +6       # if (row < height) goto <47:body>
A7 00 46 # goto +70           # goto <48:exit>
# <47:body>
10 00    # bipush 0           # 0
36 04    # vstore 4           # col = 0;
# <49:loop>
15 04    # vload 4            # col
15 01    # vload 1            # width
A1 00 06 # if_icmplt +6       # if (col < width) goto <50:body>
A7 00 27 # goto +39           # goto <51:exit>
# <50:body>
15 00    # vload 0            # A
15 03    # vload 3            # row
15 04    # vload 4            # col
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 13 # invokestatic 19    # get_index(row, col, width, height)
63       # aadds              # &A[get_index(row, col, width, height)]
2E       # imload             # A[get_index(row, col, width, height)]
B8 00 0E # invokestatic 14    # pixel_print(A[get_index(row, col, width, height)])
57       # pop                # (ignore result)
14 00 8A # aldc 138           # s[138] = " "
B7 00 03 # invokenative 3     # print(" ")
57       # pop                # (ignore result)
15 04    # vload 4            # col
10 01    # bipush 1           # 1
60       # iadd               # 
36 04    # vstore 4           # col += 1;
A7 FF D5 # goto -43           # goto <49:loop>
# <51:exit>
14 00 8C # aldc 140           # s[140] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
15 03    # vload 3            # row
10 01    # bipush 1           # 1
60       # iadd               # 
36 03    # vstore 3           # row += 1;
A7 FF B6 # goto -74           # goto <46:loop>
# <48:exit>
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<calculate_mask>
06                # number of arguments = 6
19                # number of local variables = 25
01 C0             # code length = 448 bytes
15 04    # vload 4            # maskwidth
10 02    # bipush 2           # 2
6C       # idiv               # (maskwidth / 2)
36 06    # vstore 6           # maskwidth_half = (maskwidth / 2);
15 05    # vload 5            # i
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 10 # invokestatic 16    # get_row(i, width, height)
36 07    # vstore 7           # center_row = get_row(i, width, height);
15 05    # vload 5            # i
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 11 # invokestatic 17    # get_column(i, width, height)
36 08    # vstore 8           # center_col = get_column(i, width, height);
15 07    # vload 7            # center_row
15 06    # vload 6            # maskwidth_half
64       # isub               # (center_row - maskwidth_half)
10 00    # bipush 0           # 0
B8 00 05 # invokestatic 5     # max((center_row - maskwidth_half), 0)
36 09    # vstore 9           # left_row = max((center_row - maskwidth_half), 0);
15 07    # vload 7            # center_row
15 06    # vload 6            # maskwidth_half
60       # iadd               # (center_row + maskwidth_half)
15 02    # vload 2            # height
10 01    # bipush 1           # 1
64       # isub               # (height - 1)
B8 00 06 # invokestatic 6     # min((center_row + maskwidth_half), (height - 1))
36 0A    # vstore 10          # right_row = min((center_row + maskwidth_half), (height - 1));
10 00    # bipush 0           # 0
15 09    # vload 9            # left_row
A4 00 06 # if_icmple +6       # if (0 <= left_row) goto <55:and>
A7 00 21 # goto +33           # goto <53:cond_false>
# <55:and>
15 09    # vload 9            # left_row
15 0A    # vload 10           # right_row
A4 00 06 # if_icmple +6       # if (left_row <= right_row) goto <52:cond_true>
A7 00 17 # goto +23           # goto <53:cond_false>
# <52:cond_true>
15 0A    # vload 10           # right_row
15 02    # vload 2            # height
A1 00 06 # if_icmplt +6       # if (right_row < height) goto <56:cond_true>
A7 00 08 # goto +8            # goto <57:cond_false>
# <56:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <58:cond_end>
# <57:cond_false>
10 00    # bipush 0           # false
# <58:cond_end>
A7 00 05 # goto +5            # goto <54:cond_end>
# <53:cond_false>
10 00    # bipush 0           # false
# <54:cond_end>
14 00 8E # aldc 142           # s[142] = "mask.c0: 21.5-21.74: assert failed"
CF       # assert             # assert (((0 <= left_row) && (left_row <= right_row)) && (right_row < height)) [failure message on stack]
15 08    # vload 8            # center_col
15 06    # vload 6            # maskwidth_half
64       # isub               # (center_col - maskwidth_half)
10 00    # bipush 0           # 0
B8 00 05 # invokestatic 5     # max((center_col - maskwidth_half), 0)
36 0B    # vstore 11          # up_col = max((center_col - maskwidth_half), 0);
15 08    # vload 8            # center_col
15 06    # vload 6            # maskwidth_half
60       # iadd               # (center_col + maskwidth_half)
15 01    # vload 1            # width
10 01    # bipush 1           # 1
64       # isub               # (width - 1)
B8 00 06 # invokestatic 6     # min((center_col + maskwidth_half), (width - 1))
36 0C    # vstore 12          # down_col = min((center_col + maskwidth_half), (width - 1));
10 00    # bipush 0           # 0
15 0B    # vload 11           # up_col
A4 00 06 # if_icmple +6       # if (0 <= up_col) goto <62:and>
A7 00 21 # goto +33           # goto <60:cond_false>
# <62:and>
15 0B    # vload 11           # up_col
15 0C    # vload 12           # down_col
A4 00 06 # if_icmple +6       # if (up_col <= down_col) goto <59:cond_true>
A7 00 17 # goto +23           # goto <60:cond_false>
# <59:cond_true>
15 0C    # vload 12           # down_col
15 01    # vload 1            # width
A1 00 06 # if_icmplt +6       # if (down_col < width) goto <63:cond_true>
A7 00 08 # goto +8            # goto <64:cond_false>
# <63:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <65:cond_end>
# <64:cond_false>
10 00    # bipush 0           # false
# <65:cond_end>
A7 00 05 # goto +5            # goto <61:cond_end>
# <60:cond_false>
10 00    # bipush 0           # false
# <61:cond_end>
14 00 B1 # aldc 177           # s[177] = "mask.c0: 24.5-24.67: assert failed"
CF       # assert             # assert (((0 <= up_col) && (up_col <= down_col)) && (down_col < width)) [failure message on stack]
10 FF    # bipush -1          # -1
36 0D    # vstore 13          # this_index = -(1);
10 FF    # bipush -1          # -1
36 0E    # vstore 14          # red = -(1);
10 FF    # bipush -1          # -1
36 0F    # vstore 15          # green = -(1);
10 FF    # bipush -1          # -1
36 10    # vstore 16          # blue = -(1);
10 FF    # bipush -1          # -1
36 11    # vstore 17          # average = -(1);
10 FF    # bipush -1          # -1
36 12    # vstore 18          # mask_row = -(1);
10 FF    # bipush -1          # -1
36 13    # vstore 19          # mask_col = -(1);
10 FF    # bipush -1          # -1
36 14    # vstore 20          # mask_index = -(1);
10 FF    # bipush -1          # -1
36 15    # vstore 21          # weight = -(1);
10 00    # bipush 0           # 0
36 16    # vstore 22          # result = 0;
15 09    # vload 9            # left_row
36 17    # vstore 23          # row = left_row;
# <66:loop>
15 17    # vload 23           # row
15 0A    # vload 10           # right_row
A4 00 06 # if_icmple +6       # if (row <= right_row) goto <67:body>
A7 00 DB # goto +219          # goto <68:exit>
# <67:body>
15 0B    # vload 11           # up_col
36 18    # vstore 24          # col = up_col;
# <69:loop>
15 18    # vload 24           # col
15 0C    # vload 12           # down_col
A4 00 06 # if_icmple +6       # if (col <= down_col) goto <70:body>
A7 00 C3 # goto +195          # goto <71:exit>
# <70:body>
15 17    # vload 23           # row
15 18    # vload 24           # col
15 01    # vload 1            # width
15 02    # vload 2            # height
B8 00 13 # invokestatic 19    # get_index(row, col, width, height)
36 0D    # vstore 13          # this_index = get_index(row, col, width, height);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 09 # invokestatic 9     # get_red(pixels[this_index])
36 0E    # vstore 14          # red = get_red(pixels[this_index]);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 0A # invokestatic 10    # get_green(pixels[this_index])
36 0F    # vstore 15          # green = get_green(pixels[this_index]);
15 00    # vload 0            # pixels
15 0D    # vload 13           # this_index
63       # aadds              # &pixels[this_index]
2E       # imload             # pixels[this_index]
B8 00 0B # invokestatic 11    # get_blue(pixels[this_index])
36 10    # vstore 16          # blue = get_blue(pixels[this_index]);
15 0E    # vload 14           # red
15 0F    # vload 15           # green
60       # iadd               # (red + green)
15 10    # vload 16           # blue
60       # iadd               # ((red + green) + blue)
10 03    # bipush 3           # 3
6C       # idiv               # (((red + green) + blue) / 3)
36 11    # vstore 17          # average = (((red + green) + blue) / 3);
15 06    # vload 6            # maskwidth_half
15 07    # vload 7            # center_row
15 17    # vload 23           # row
64       # isub               # (center_row - row)
64       # isub               # (maskwidth_half - (center_row - row))
36 12    # vstore 18          # mask_row = (maskwidth_half - (center_row - row));
15 06    # vload 6            # maskwidth_half
15 08    # vload 8            # center_col
15 18    # vload 24           # col
64       # isub               # (center_col - col)
64       # isub               # (maskwidth_half - (center_col - col))
36 13    # vstore 19          # mask_col = (maskwidth_half - (center_col - col));
10 00    # bipush 0           # 0
15 12    # vload 18           # mask_row
A4 00 06 # if_icmple +6       # if (0 <= mask_row) goto <72:cond_true>
A7 00 17 # goto +23           # goto <73:cond_false>
# <72:cond_true>
15 12    # vload 18           # mask_row
15 04    # vload 4            # maskwidth
A1 00 06 # if_icmplt +6       # if (mask_row < maskwidth) goto <75:cond_true>
A7 00 08 # goto +8            # goto <76:cond_false>
# <75:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <77:cond_end>
# <76:cond_false>
10 00    # bipush 0           # false
# <77:cond_end>
A7 00 05 # goto +5            # goto <74:cond_end>
# <73:cond_false>
10 00    # bipush 0           # false
# <74:cond_end>
14 00 D4 # aldc 212           # s[212] = "mask.c0: 59.13-59.59: assert failed"
CF       # assert             # assert ((0 <= mask_row) && (mask_row < maskwidth)) [failure message on stack]
10 00    # bipush 0           # 0
15 13    # vload 19           # mask_col
A4 00 06 # if_icmple +6       # if (0 <= mask_col) goto <78:cond_true>
A7 00 17 # goto +23           # goto <79:cond_false>
# <78:cond_true>
15 13    # vload 19           # mask_col
15 04    # vload 4            # maskwidth
A1 00 06 # if_icmplt +6       # if (mask_col < maskwidth) goto <81:cond_true>
A7 00 08 # goto +8            # goto <82:cond_false>
# <81:cond_true>
10 01    # bipush 1           # true
A7 00 05 # goto +5            # goto <83:cond_end>
# <82:cond_false>
10 00    # bipush 0           # false
# <83:cond_end>
A7 00 05 # goto +5            # goto <80:cond_end>
# <79:cond_false>
10 00    # bipush 0           # false
# <80:cond_end>
14 00 F8 # aldc 248           # s[248] = "mask.c0: 60.13-60.59: assert failed"
CF       # assert             # assert ((0 <= mask_col) && (mask_col < maskwidth)) [failure message on stack]
15 12    # vload 18           # mask_row
15 13    # vload 19           # mask_col
15 04    # vload 4            # maskwidth
15 04    # vload 4            # maskwidth
B8 00 13 # invokestatic 19    # get_index(mask_row, mask_col, maskwidth, maskwidth)
36 14    # vstore 20          # mask_index = get_index(mask_row, mask_col, maskwidth, maskwidth);
15 03    # vload 3            # mask
15 14    # vload 20           # mask_index
63       # aadds              # &mask[mask_index]
2E       # imload             # mask[mask_index]
36 15    # vstore 21          # weight = mask[mask_index];
15 16    # vload 22           # result
15 11    # vload 17           # average
15 15    # vload 21           # weight
68       # imul               # (average * weight)
60       # iadd               # 
36 16    # vstore 22          # result += (average * weight);
15 18    # vload 24           # col
10 01    # bipush 1           # 1
60       # iadd               # 
36 18    # vstore 24          # col += 1;
A7 FF 39 # goto -199          # goto <69:loop>
# <71:exit>
15 17    # vload 23           # row
10 01    # bipush 1           # 1
60       # iadd               # 
36 17    # vstore 23          # row += 1;
A7 FF 21 # goto -223          # goto <66:loop>
# <68:exit>
15 16    # vload 22           # result
B0       # return             # 


#<apply_mask>
05                # number of arguments = 5
09                # number of local variables = 9
00 69             # code length = 105 bytes
15 01    # vload 1            # width
15 02    # vload 2            # height
68       # imul               # (width * height)
BC 04    # newarray 4         # alloc_array(int, (width * height))
36 05    # vstore 5           # masked_pixels = alloc_array(int, (width * height));
10 FF    # bipush -1          # -1
36 06    # vstore 6           # result = -(1);
15 01    # vload 1            # width
15 02    # vload 2            # height
68       # imul               # (width * height)
36 07    # vstore 7           # limit = (width * height);
10 00    # bipush 0           # 0
36 08    # vstore 8           # i = 0;
# <84:loop>
15 08    # vload 8            # i
15 07    # vload 7            # limit
A1 00 06 # if_icmplt +6       # if (i < limit) goto <85:body>
A7 00 47 # goto +71           # goto <86:exit>
# <85:body>
14 01 1C # aldc 284           # s[284] = "i="
B7 00 03 # invokenative 3     # print("i=")
57       # pop                # (ignore result)
15 08    # vload 8            # i
B7 00 06 # invokenative 6     # printint(i)
57       # pop                # (ignore result)
14 01 1F # aldc 287           # s[287] = ", limit="
B7 00 03 # invokenative 3     # print(", limit=")
57       # pop                # (ignore result)
15 07    # vload 7            # limit
B7 00 06 # invokenative 6     # printint(limit)
57       # pop                # (ignore result)
14 01 28 # aldc 296           # s[296] = ", calling calculate\n"
B7 00 03 # invokenative 3     # print(", calling calculate\n")
57       # pop                # (ignore result)
15 00    # vload 0            # pixels
15 01    # vload 1            # width
15 02    # vload 2            # height
15 03    # vload 3            # mask
15 04    # vload 4            # maskwidth
15 08    # vload 8            # i
B8 00 15 # invokestatic 21    # calculate_mask(pixels, width, height, mask, maskwidth, i)
36 06    # vstore 6           # result = calculate_mask(pixels, width, height, mask, maskwidth, i);
15 05    # vload 5            # masked_pixels
15 08    # vload 8            # i
63       # aadds              # &masked_pixels[i]
15 06    # vload 6            # result
4E       # imstore            # masked_pixels[i] = result;
15 08    # vload 8            # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 08    # vstore 8           # i += 1;
A7 FF B5 # goto -75           # goto <84:loop>
# <86:exit>
15 05    # vload 5            # masked_pixels
B0       # return             # 


#<mask_main>
03                # number of arguments = 3
10                # number of local variables = 16
02 C1             # code length = 705 bytes
14 01 3D # aldc 317           # s[317] = "Input image file:  "
B7 00 03 # invokenative 3     # print("Input image file:  ")
57       # pop                # (ignore result)
15 00    # vload 0            # input
B7 00 03 # invokenative 3     # print(input)
57       # pop                # (ignore result)
14 01 51 # aldc 337           # s[337] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
14 01 53 # aldc 339           # s[339] = "Output image file: "
B7 00 03 # invokenative 3     # print("Output image file: ")
57       # pop                # (ignore result)
15 01    # vload 1            # output
B7 00 03 # invokenative 3     # print(output)
57       # pop                # (ignore result)
14 01 67 # aldc 359           # s[359] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
14 01 69 # aldc 361           # s[361] = "Blur mask file:    "
B7 00 03 # invokenative 3     # print("Blur mask file:    ")
57       # pop                # (ignore result)
15 02    # vload 2            # mask
B7 00 03 # invokenative 3     # print(mask)
57       # pop                # (ignore result)
14 01 7D # aldc 381           # s[381] = "\n\n"
B7 00 03 # invokenative 3     # print("\n\n")
57       # pop                # (ignore result)
15 00    # vload 0            # input
B7 00 07 # invokenative 7     # image_load(input)
36 03    # vstore 3           # source = image_load(input);
15 03    # vload 3            # source
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (source == NULL) goto <87:then>
A7 00 0A # goto +10           # goto <88:else>
# <87:then>
14 01 80 # aldc 384           # s[384] = "Could not load source image"
BF       # athrow             # error "Could not load source image"
A7 00 03 # goto +3            # goto <89:endif>
# <88:else>
# <89:endif>
15 03    # vload 3            # source
B7 00 08 # invokenative 8     # image_width(source)
36 04    # vstore 4           # width = image_width(source);
15 03    # vload 3            # source
B7 00 09 # invokenative 9     # image_height(source)
36 05    # vstore 5           # height = image_height(source);
15 03    # vload 3            # source
B7 00 0A # invokenative 10    # image_data(source)
36 06    # vstore 6           # inpixels = image_data(source);
14 01 9C # aldc 412           # s[412] = "Loaded image.  Dimensions are "
B7 00 03 # invokenative 3     # print("Loaded image.  Dimensions are ")
57       # pop                # (ignore result)
15 04    # vload 4            # width
B7 00 06 # invokenative 6     # printint(width)
57       # pop                # (ignore result)
14 01 BB # aldc 443           # s[443] = " by "
B7 00 03 # invokenative 3     # print(" by ")
57       # pop                # (ignore result)
15 05    # vload 5            # height
B7 00 06 # invokenative 6     # printint(height)
57       # pop                # (ignore result)
14 01 C0 # aldc 448           # s[448] = ".\n"
B7 00 03 # invokenative 3     # print(".\n")
57       # pop                # (ignore result)
15 02    # vload 2            # mask
B7 00 0B # invokenative 11    # file_read(mask)
36 07    # vstore 7           # file = file_read(mask);
15 07    # vload 7            # file
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (file == NULL) goto <90:then>
A7 00 0A # goto +10           # goto <91:else>
# <90:then>
14 01 C3 # aldc 451           # s[451] = "Unable to read mask file. Try again."
BF       # athrow             # error "Unable to read mask file. Try again."
A7 00 03 # goto +3            # goto <92:endif>
# <91:else>
# <92:endif>
15 07    # vload 7            # file
B7 00 0D # invokenative 13    # file_readline(file)
10 0A    # bipush 10          # 10
B7 00 0C # invokenative 12    # parse_int(file_readline(file), 10)
36 08    # vstore 8           # size = parse_int(file_readline(file), 10);
15 08    # vload 8            # size
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (size == NULL) goto <93:then>
A7 00 0A # goto +10           # goto <94:else>
# <93:then>
14 01 E8 # aldc 488           # s[488] = "Invalid blur mask size"
BF       # athrow             # error "Invalid blur mask size"
A7 00 03 # goto +3            # goto <95:endif>
# <94:else>
# <95:endif>
14 01 FF # aldc 511           # s[511] = "Mask Width: "
B7 00 03 # invokenative 3     # print("Mask Width: ")
57       # pop                # (ignore result)
15 08    # vload 8            # size
2E       # imload             # *(size)
B7 00 06 # invokenative 6     # printint(*(size))
57       # pop                # (ignore result)
14 02 0C # aldc 524           # s[524] = "\n"
B7 00 03 # invokenative 3     # print("\n")
57       # pop                # (ignore result)
15 08    # vload 8            # size
01       # aconst_null        # NULL
9F 00 1F # if_cmpeq +31       # if (size == NULL) goto <96:then>
A7 00 03 # goto +3            # goto <100:or>
# <100:or>
15 08    # vload 8            # size
2E       # imload             # *(size)
10 00    # bipush 0           # 0
A1 00 14 # if_icmplt +20      # if (*(size) < 0) goto <96:then>
A7 00 03 # goto +3            # goto <99:or>
# <99:or>
15 08    # vload 8            # size
2E       # imload             # *(size)
10 02    # bipush 2           # 2
70       # irem               # (*(size) % 2)
10 01    # bipush 1           # 1
A0 00 06 # if_cmpne +6        # if ((*(size) % 2) != 1) goto <96:then>
A7 00 0A # goto +10           # goto <97:else>
# <96:then>
14 02 0E # aldc 526           # s[526] = "Invalid blur mask size"
BF       # athrow             # error "Invalid blur mask size"
A7 00 03 # goto +3            # goto <98:endif>
# <97:else>
# <98:endif>
15 08    # vload 8            # size
2E       # imload             # *(size)
15 08    # vload 8            # size
2E       # imload             # *(size)
68       # imul               # (*(size) * *(size))
BC 04    # newarray 4         # alloc_array(int, (*(size) * *(size)))
36 09    # vstore 9           # blurmask = alloc_array(int, (*(size) * *(size)));
10 00    # bipush 0           # 0
36 0A    # vstore 10          # i = 0;
# <101:loop>
15 07    # vload 7            # file
B7 00 0E # invokenative 14    # file_eof(file)
10 01    # bipush 1           # true
9F 00 40 # if_cmpeq +64       # if (file_eof(file) == true) goto <103:exit>
A7 00 03 # goto +3            # goto <102:body>
# <102:body>
15 07    # vload 7            # file
B7 00 0D # invokenative 13    # file_readline(file)
10 0A    # bipush 10          # 10
B7 00 0C # invokenative 12    # parse_int(file_readline(file), 10)
36 0B    # vstore 11          # value = parse_int(file_readline(file), 10);
15 0B    # vload 11           # value
01       # aconst_null        # NULL
9F 00 06 # if_cmpeq +6        # if (value == NULL) goto <104:then>
A7 00 15 # goto +21           # goto <105:else>
# <104:then>
14 02 25 # aldc 549           # s[549] = "Invalid weight on line "
15 0A    # vload 10           # i
10 02    # bipush 2           # 2
60       # iadd               # (i + 2)
B7 00 10 # invokenative 16    # string_fromint((i + 2))
B7 00 0F # invokenative 15    # string_join("Invalid weight on line ", string_fromint((i + 2)))
BF       # athrow             # error string_join("Invalid weight on line ", string_fromint((i + 2)))
A7 00 03 # goto +3            # goto <106:endif>
# <105:else>
# <106:endif>
15 09    # vload 9            # blurmask
15 0A    # vload 10           # i
63       # aadds              # &blurmask[i]
15 0B    # vload 11           # value
2E       # imload             # *(value)
4E       # imstore            # blurmask[i] = *(value);
15 0A    # vload 10           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0A    # vstore 10          # i += 1;
A7 FF BC # goto -68           # goto <101:loop>
# <103:exit>
15 0A    # vload 10           # i
15 08    # vload 8            # size
2E       # imload             # *(size)
15 08    # vload 8            # size
2E       # imload             # *(size)
68       # imul               # (*(size) * *(size))
A0 00 06 # if_cmpne +6        # if (i != (*(size) * *(size))) goto <107:then>
A7 00 0A # goto +10           # goto <108:else>
# <107:then>
14 02 3D # aldc 573           # s[573] = "Incorrect number of weights in mask file"
BF       # athrow             # error "Incorrect number of weights in mask file"
A7 00 03 # goto +3            # goto <109:endif>
# <108:else>
# <109:endif>
14 02 66 # aldc 614           # s[614] = "Applying mask..."
B7 00 03 # invokenative 3     # print("Applying mask...")
57       # pop                # (ignore result)
B7 00 11 # invokenative 17    # flush()
57       # pop                # (ignore result)
15 06    # vload 6            # inpixels
15 04    # vload 4            # width
15 05    # vload 5            # height
15 09    # vload 9            # blurmask
15 08    # vload 8            # size
2E       # imload             # *(size)
B8 00 16 # invokestatic 22    # apply_mask(inpixels, width, height, blurmask, *(size))
36 0B    # vstore 11          # masked = apply_mask(inpixels, width, height, blurmask, *(size));
14 02 77 # aldc 631           # s[631] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
10 00    # bipush 0           # 0
36 0C    # vstore 12          # masksum = 0;
10 00    # bipush 0           # 0
36 0A    # vstore 10          # i = 0;
# <110:loop>
15 0A    # vload 10           # i
15 08    # vload 8            # size
2E       # imload             # *(size)
15 08    # vload 8            # size
2E       # imload             # *(size)
68       # imul               # (*(size) * *(size))
A1 00 06 # if_icmplt +6       # if (i < (*(size) * *(size))) goto <111:body>
A7 00 18 # goto +24           # goto <112:exit>
# <111:body>
15 0C    # vload 12           # masksum
15 09    # vload 9            # blurmask
15 0A    # vload 10           # i
63       # aadds              # &blurmask[i]
2E       # imload             # blurmask[i]
60       # iadd               # 
36 0C    # vstore 12          # masksum += blurmask[i];
15 0A    # vload 10           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0A    # vstore 10          # i += 1;
A7 FF DF # goto -33           # goto <110:loop>
# <112:exit>
15 0C    # vload 12           # masksum
10 00    # bipush 0           # 0
9F 00 06 # if_cmpeq +6        # if (masksum == 0) goto <113:then>
A7 00 0A # goto +10           # goto <114:else>
# <113:then>
10 01    # bipush 1           # 1
36 0C    # vstore 12          # masksum = 1;
A7 00 03 # goto +3            # goto <115:endif>
# <114:else>
# <115:endif>
15 04    # vload 4            # width
15 05    # vload 5            # height
68       # imul               # (width * height)
BC 04    # newarray 4         # alloc_array(int, (width * height))
36 0D    # vstore 13          # data = alloc_array(int, (width * height));
10 00    # bipush 0           # 0
36 0A    # vstore 10          # i = 0;
# <116:loop>
15 0A    # vload 10           # i
15 04    # vload 4            # width
15 05    # vload 5            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (i < (width * height)) goto <117:body>
A7 00 72 # goto +114          # goto <118:exit>
# <117:body>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
15 0B    # vload 11           # masked
15 0A    # vload 10           # i
63       # aadds              # &masked[i]
2E       # imload             # masked[i]
15 0C    # vload 12           # masksum
6C       # idiv               # (masked[i] / masksum)
4E       # imstore            # data[i] = (masked[i] / masksum);
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
13 00 06 # ildc 6             # c[6] = 255
A3 00 06 # if_icmpgt +6       # if (data[i] > 255) goto <119:then>
A7 00 0F # goto +15           # goto <120:else>
# <119:then>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
13 00 07 # ildc 7             # c[7] = 255
4E       # imstore            # data[i] = 255;
A7 00 03 # goto +3            # goto <121:endif>
# <120:else>
# <121:endif>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
13 00 08 # ildc 8             # c[8] = -255
A1 00 06 # if_icmplt +6       # if (data[i] < -(255)) goto <122:then>
A7 00 0F # goto +15           # goto <123:else>
# <122:then>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
13 00 09 # ildc 9             # c[9] = 255
4E       # imstore            # data[i] = 255;
A7 00 03 # goto +3            # goto <124:endif>
# <123:else>
# <124:endif>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
10 00    # bipush 0           # 0
A1 00 06 # if_icmplt +6       # if (data[i] < 0) goto <125:then>
A7 00 15 # goto +21           # goto <126:else>
# <125:then>
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
10 00    # bipush 0           # 
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
64       # isub               # -(data[i])
4E       # imstore            # data[i] = -(data[i]);
A7 00 03 # goto +3            # goto <127:endif>
# <126:else>
# <127:endif>
15 0A    # vload 10           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0A    # vstore 10          # i += 1;
A7 FF 87 # goto -121          # goto <116:loop>
# <118:exit>
15 04    # vload 4            # width
15 05    # vload 5            # height
B7 00 12 # invokenative 18    # image_create(width, height)
36 0E    # vstore 14          # dest = image_create(width, height);
15 0E    # vload 14           # dest
B7 00 0A # invokenative 10    # image_data(dest)
36 0F    # vstore 15          # outpixels = image_data(dest);
10 00    # bipush 0           # 0
36 0A    # vstore 10          # i = 0;
# <128:loop>
15 0A    # vload 10           # i
15 04    # vload 4            # width
15 05    # vload 5            # height
68       # imul               # (width * height)
A1 00 06 # if_icmplt +6       # if (i < (width * height)) goto <129:body>
A7 00 38 # goto +56           # goto <130:exit>
# <129:body>
15 0F    # vload 15           # outpixels
15 0A    # vload 10           # i
63       # aadds              # &outpixels[i]
15 06    # vload 6            # inpixels
15 0A    # vload 10           # i
63       # aadds              # &inpixels[i]
2E       # imload             # inpixels[i]
13 00 0A # ildc 10            # c[10] = -16777216
7E       # iand               # (inpixels[i] & -16777216)
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
10 10    # bipush 16          # 16
78       # ishl               # (data[i] << 16)
80       # ior                # ((inpixels[i] & -16777216) | (data[i] << 16))
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
10 08    # bipush 8           # 8
78       # ishl               # (data[i] << 8)
80       # ior                # (((inpixels[i] & -16777216) | (data[i] << 16)) | (data[i] << 8))
15 0D    # vload 13           # data
15 0A    # vload 10           # i
63       # aadds              # &data[i]
2E       # imload             # data[i]
80       # ior                # ((((inpixels[i] & -16777216) | (data[i] << 16)) | (data[i] << 8)) | data[i])
4E       # imstore            # outpixels[i] = ((((inpixels[i] & -16777216) | (data[i] << 16)) | (data[i] << 8)) | data[i]);
15 0A    # vload 10           # i
10 01    # bipush 1           # 1
60       # iadd               # 
36 0A    # vstore 10          # i += 1;
A7 FF C1 # goto -63           # goto <128:loop>
# <130:exit>
14 02 7E # aldc 638           # s[638] = "Saving output..."
B7 00 03 # invokenative 3     # print("Saving output...")
57       # pop                # (ignore result)
B7 00 11 # invokenative 17    # flush()
57       # pop                # (ignore result)
15 0E    # vload 14           # dest
15 01    # vload 1            # output
B7 00 13 # invokenative 19    # image_save(dest, output)
57       # pop                # (ignore result)
14 02 8F # aldc 655           # s[655] = "done.\n"
B7 00 03 # invokenative 3     # print("done.\n")
57       # pop                # (ignore result)
10 00    # bipush 0           # dummy return value
B0       # return             # 


#<default_output>
02                # number of arguments = 2
04                # number of local variables = 4
00 60             # code length = 96 bytes
15 00    # vload 0            # input
B7 00 14 # invokenative 20    # string_length(input)
36 02    # vstore 2           # len = string_length(input);
15 02    # vload 2            # len
10 04    # bipush 4           # 4
A3 00 06 # if_icmpgt +6       # if (len > 4) goto <134:and>
A7 00 1D # goto +29           # goto <131:then>
# <134:and>
14 02 96 # aldc 662           # s[662] = ".png"
15 00    # vload 0            # input
15 02    # vload 2            # len
10 04    # bipush 4           # 4
64       # isub               # (len - 4)
15 02    # vload 2            # len
B7 00 15 # invokenative 21    # string_sub(input, (len - 4), len)
B7 00 05 # invokenative 5     # string_equal(".png", string_sub(input, (len - 4), len))
10 01    # bipush 1           # true
9F 00 0D # if_cmpeq +13       # if (string_equal(".png", string_sub(input, (len - 4), len)) == true) goto <132:else>
A7 00 03 # goto +3            # goto <131:then>
# <131:then>
14 02 9B # aldc 667           # s[667] = "Input file does not end with .png"
BF       # athrow             # error "Input file does not end with .png"
A7 00 03 # goto +3            # goto <133:endif>
# <132:else>
# <133:endif>
15 00    # vload 0            # input
10 00    # bipush 0           # 0
15 02    # vload 2            # len
10 04    # bipush 4           # 4
64       # isub               # (len - 4)
B7 00 15 # invokenative 21    # string_sub(input, 0, (len - 4))
36 03    # vstore 3           # res = string_sub(input, 0, (len - 4));
15 03    # vload 3            # res
14 02 BD # aldc 701           # s[701] = "_"
B7 00 0F # invokenative 15    # string_join(res, "_")
36 03    # vstore 3           # res = string_join(res, "_");
15 03    # vload 3            # res
15 01    # vload 1            # name
B7 00 0F # invokenative 15    # string_join(res, name)
36 03    # vstore 3           # res = string_join(res, name);
15 03    # vload 3            # res
14 02 BF # aldc 703           # s[703] = ".png"
B7 00 0F # invokenative 15    # string_join(res, ".png")
36 03    # vstore 3           # res = string_join(res, ".png");
15 03    # vload 3            # res
B0       # return             # 

00 18             # native count
# native pool
00 01 00 5B       # char_chr
00 01 00 5C       # char_ord
00 01 00 60       # string_from_chararray
00 01 00 06       # print
00 00 00 0B       # readline
00 02 00 5F       # string_equal
00 01 00 09       # printint
00 01 00 51       # image_load
00 01 00 54       # image_width
00 01 00 50       # image_height
00 01 00 4F       # image_data
00 01 00 41       # file_read
00 02 00 58       # parse_int
00 01 00 42       # file_readline
00 01 00 40       # file_eof
00 02 00 64       # string_join
00 01 00 63       # string_fromint
00 00 00 05       # flush
00 02 00 4E       # image_create
00 02 00 52       # image_save
00 01 00 65       # string_length
00 03 00 66       # string_sub
00 02 00 03       # args_string
00 00 00 02       # args_parse

